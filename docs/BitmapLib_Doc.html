<h1>Python BMP Public API</h1>
<h3><a href="#Python_BMP.BITMAPlib._1bmof"><code>_1bmof</code></a></h3>
<p><code>py
def _1bmof(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with 1 bit color data given x and y data</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._1bmofhd"><code>_1bmofhd</code></a></h3>
<p><code>py
def _1bmofhd(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
    with 1 bit color data given
    x and y with adjustments
    made for a bmp header</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._24bmof"><code>_24bmof</code></a></h3>
<p><code>py
def _24bmof(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array with RGB data given x and y</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    x,y: unsigned int value
         of location in
         x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._24bmofhd"><code>_24bmofhd</code></a></h3>
<p><code>py
def _24bmofhd(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with RGB data given x and y with bmp header</p>
<pre><code>Args:
    bmp:  unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._4bmof"><code>_4bmof</code></a></h3>
<p><code>py
def _4bmof(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with 4 bit color data given x and y data</p>
<pre><code>Args:
    bmp:  unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._4bmofhd"><code>_4bmofhd</code></a></h3>
<p><code>py
def _4bmofhd(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with 4 bit color data given
x and y with adjustments
made due to a header</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._8bmof"><code>_8bmof</code></a></h3>
<p><code>py
def _8bmof(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with 8 bit color data given x and y data</p>
<pre><code>Args:
    bmp:  unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to
    that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._8bmofhd"><code>_8bmofhd</code></a></h3>
<p><code>py
def _8bmofhd(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Get the offset in a byte array
with 8 bit color data given
x and y with adjustments
made for a bmp header</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location in
          x-axis and y-axis

Returns:
    int value of offset to
    that data in byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._bmmeta"><code>_bmmeta</code></a></h3>
<p><code>py
def _bmmeta(x: int, y: int, bits: int) -&gt; tuple:</code></p>
<p>Computes bitmap meta data</p>
<pre><code>Args:
    x, y : unsigned int
           values of the
           x and y dimension
    bits : bit depth (1, 4, 8, 24)

Returns:
    unsigned int values for
    (filesize, headersize,
    xdim, ydim, bitdepth)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._BMoffset"><code>_BMoffset</code></a></h3>
<p><code>py
def _BMoffset(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Returns the offset given a bmp and (x, y) coordinates</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int location
          in x-axis and y-axis

Returns:
    unsigned int offset to data in buffer
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._BMoffsethd"><code>_BMoffsethd</code></a></h3>
<p><code>py
def _BMoffsethd(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Returns the offset given a bmp
and (x, y) coordinates with header considered</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int location
          in x-axis and y-axis

Returns:
    unsigned int offset to data in buffer
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._cmpimglines"><code>_cmpimglines</code></a></h3>
<p><code>py
def _cmpimglines(bmp: array.array, x1: int, y1: int, x2: int, y2: int, func: Callable):</code></p>
<h3><a href="#Python_BMP.BITMAPlib._flsz"><code>_flsz</code></a></h3>
<p><code>py
def _flsz(bmp: array.array) -&gt; int:</code></p>
<p>Get the file size of a win bmp
    from its bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    unsigned int value of size
    of the bmp header
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._fnwithpar2vertslice"><code>_fnwithpar2vertslice</code></a></h3>
<p><code>py
def _fnwithpar2vertslice(bmp: array.array, x: int, y1: int, y2: int, func: Callable, funcparam):</code></p>
<p>Apply a user defined function to vertical slices</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y1, y2 : unsigned int
                x and y coordinates
    func      : user defined function
    funcparam : parameters of
                the user defined
                function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._getbmflsz"><code>_getbmflsz</code></a></h3>
<p><code>py
def _getbmflsz(x: int, y: int, bits: int) -&gt; int:</code></p>
<p>Computes bitmap file size</p>
<pre><code>Args:
    x, y: unsigned int value
          of x and y dimensions
    bits: bit depth (1, 4, 8, 24)

Returns:
    int value of file size
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._getBMofffunc"><code>_getBMofffunc</code></a></h3>
<p><code>py
def _getBMofffunc(bmp: array.array):</code></p>
<p>Returns the correct function
to use in computing the offset
in a given bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    function to compute offsets
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._getBMoffhdfunc"><code>_getBMoffhdfunc</code></a></h3>
<p><code>py
def _getBMoffhdfunc(bmp: array.array):</code></p>
<p>Returns the correct function
to use in computing offsets
with headers in a given bmp</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    function to compute offsets with headers
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._getclrbits"><code>_getclrbits</code></a></h3>
<p><code>py
def _getclrbits(bmp: array.array) -&gt; int:</code></p>
<p>Get the bit depth of BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    int value of bit depth
    (1, 4, 8, 24) bits
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._hdsz"><code>_hdsz</code></a></h3>
<p><code>py
def _hdsz(bmp: array.array) -&gt; int:</code></p>
<p>Get the header size of a BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    int value of header size
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._pdbytes"><code>_pdbytes</code></a></h3>
<p><code>py
def _pdbytes(x: int, bits: int) -&gt; int:</code></p>
<p>Get the number of bytes used to pad for
32-bit alignment given x dimension and bit depth</p>
<pre><code>Args:
    x   : unsigned int value of
          x-dimension
    bits: unsigned int value of
          bit depth (1, 4, 8, 24)

Returns:
    int value of number of pad bytes
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._setflsz"><code>_setflsz</code></a></h3>
<p><code>py
def _setflsz(bmp: array.array, size: int):</code></p>
<p>Set the file size of a BMP</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    size : unsigned int value
           of size of
           the bmp file

Returns:
    byref modified unsigned byte array
    with new file size
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._sethdsz"><code>_sethdsz</code></a></h3>
<p><code>py
def _sethdsz(bmp: array.array, hdsize: int):</code></p>
<p>Set the header size of a win bmp</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    hdsize: unsigned int value
            of size of the
            bmp header

Returns:
    byref modified byte array
    with new header size
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._setmeta"><code>_setmeta</code></a></h3>
<p><code>py
def _setmeta(bmpmeta: list) -&gt; array.array:</code></p>
<p>Creates a new bitmap
    with the properties set
    by bmpmeta to
    a new unsigned byte array</p>
<pre><code>Args:
    bmpmeta: [filesize, hdrsize,
              x, y, bits]

Returns:
    unsigned byte array with bmp format
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._setx"><code>_setx</code></a></h3>
<p><code>py
def _setx(bmp: array.array, xmax: int):</code></p>
<p>Sets the x value stored in the windows bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    int: value of x dimension

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._sety"><code>_sety</code></a></h3>
<p><code>py
def _sety(bmp: array.array, ymax: int):</code></p>
<p>Sets the y value stored in the windows bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    int: value of y dimension

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24bitfn2reg"><code>_use24bitfn2reg</code></a></h3>
<p><code>py
def _use24bitfn2reg(bmp: array.array, x1: int, y1: int, x2: int, y2: int, func: Callable, funcparam):</code></p>
<p>Apply func(funcparam) to a rectangular area
in a 24-bit bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular area
    func          : user defined
                    function
    funcparam     : parameters of
                    the function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btbyrefclrfn2regnsv"><code>_use24btbyrefclrfn2regnsv</code></a></h3>
<p><code>py
def _use24btbyrefclrfn2regnsv(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, func: Callable, funcparam):</code></p>
<p>Apply a 24-bit byref
color modification function
to a rectangular area and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2:  the rectangular
                     area
    func           : user defined
                     function
    funcparam      : function
                     parameters

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btclrfn"><code>_use24btclrfn</code></a></h3>
<p><code>py
def _use24btclrfn(ExistingBMPfile: str, NewBMPfile: str, func: Callable, funcparam):</code></p>
<p>Apply a user provided color adjustment function
to a 24-bit bitmap</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save the
                     changes in
    func           : user defined
                     function
    funcparam      : parameters of
                     the function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btclrfntocircregion"><code>_use24btclrfntocircregion</code></a></h3>
<p><code>py
def _use24btclrfntocircregion(ExistingBMPfile: str, NewBMPfile: str, func: Callable, x: int, y: int, r: int):</code></p>
<p>Apply a no parameter color adjustment function
to a circular area (24-bit only)</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btclrfnwithpar2circreg"><code>_use24btclrfnwithpar2circreg</code></a></h3>
<p><code>py
def _use24btclrfnwithpar2circreg(ExistingBMPfile: str, NewBMPfile: str, func: Callable, x: int, y: int, r: int, funcparam):</code></p>
<p>Apply a user provided color adjustment function
to a circular area (24-bit only)</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x,y)
                     and radius r
    func           : user defined
                     function
    funcparam      : parameters of
                     the function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btfn2circreg"><code>_use24btfn2circreg</code></a></h3>
<p><code>py
def _use24btfn2circreg(bmp: array.array, x: int, y: int, r: int, func: Callable, funcparam):</code></p>
<p>Apply function func to a
circular region with center at
(x, y) and a radius r that is
within a 24-bit bitmap</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y, r   : center (x, y)
                and radius r
                of the circular area
    func      : function to apply
    funcparam : parameters of the
                function

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._use24btfnwithparnsv"><code>_use24btfnwithparnsv</code></a></h3>
<p><code>py
def _use24btfnwithparnsv(ExistingBMPfile: str, NewBMPfile: str, func: Callable, funcparam):</code></p>
<p>Apply a 24-bit only function with parameters and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    func           : user defined
                     function
    funcparam      : parameters of
                     the function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyref24btfn2reg"><code>_usebyref24btfn2reg</code></a></h3>
<p><code>py
def _usebyref24btfn2reg(bmp: array.array, x1: int, y1: int, x2: int, y2: int, func: Callable, funcparam):</code></p>
<p>Apply byref func(funcparam) to a rectangular area
in a 24-bit bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular area
    func          : user defined
                    function
    funcparam     : parameters of
                    the function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyref24btfn2regnsv"><code>_usebyref24btfn2regnsv</code></a></h3>
<p><code>py
def _usebyref24btfn2regnsv(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, func: Callable):</code></p>
<p>Apply a 24-bit byref function
with no parameters to a
rectangular area and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyreffn2regnsv"><code>_usebyreffn2regnsv</code></a></h3>
<p><code>py
def _usebyreffn2regnsv(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, func: Callable):</code></p>
<p>Apply a byref function
with no parameters to a
rectangular region and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyreffnsv"><code>_usebyreffnsv</code></a></h3>
<p><code>py
def _usebyreffnsv(ExistingBMPfile: str, NewBMPfile: str, func: Callable):</code></p>
<p>Apply a by-ref function with no parameters and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyreffnwithpar2regnsv"><code>_usebyreffnwithpar2regnsv</code></a></h3>
<p><code>py
def _usebyreffnwithpar2regnsv(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, func: Callable, funcparam):</code></p>
<p>Apply a 24-bit byref function
to a rectangular area and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     area
    func           : user defined
                     function
    funcparam      : function
                     parameters

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usebyreffnwithparnsv"><code>_usebyreffnwithparnsv</code></a></h3>
<p><code>py
def _usebyreffnwithparnsv(ExistingBMPfile: str, NewBMPfile: str, func: Callable, funcparam):</code></p>
<h3><a href="#Python_BMP.BITMAPlib._usebyrefnopar24bitfn2reg"><code>_usebyrefnopar24bitfn2reg</code></a></h3>
<p><code>py
def _usebyrefnopar24bitfn2reg(bmp: array.array, x1: int, y1: int, x2: int, y2: int, func: Callable):</code></p>
<p>Apply a func to a rectangular area in a 24-bit bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    area
    func          : user defined
                    function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._useclradjfn"><code>_useclradjfn</code></a></h3>
<p><code>py
def _useclradjfn(ExistingBMPfile: str, NewBMPfile: str, func: Callable, funcparam):</code></p>
<p>Apply a user provided color adjustmen function
to an existing bitmap</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    func           : user defined
                     function
    funcparam      : parameters of
                     the function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usefn2circreg"><code>_usefn2circreg</code></a></h3>
<p><code>py
def _usefn2circreg(ExistingBMPfile: str, NewBMPfile: str, func: Callable, x: int, y: int, r: int):</code></p>
<p>Apply a user provided function (no parameters)
to a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usefn2regsv"><code>_usefn2regsv</code></a></h3>
<p><code>py
def _usefn2regsv(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, func: Callable):</code></p>
<p>Apply a function withno parameters to a
rectangular area and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usefnsv"><code>_usefnsv</code></a></h3>
<p><code>py
def _usefnsv(ExistingBMPfile: str, NewBMPfile: str, func: Callable):</code></p>
<p>Apply a function with no parameters and save</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usefnwithpar2circreg"><code>_usefnwithpar2circreg</code></a></h3>
<p><code>py
def _usefnwithpar2circreg(ExistingBMPfile: str, NewBMPfile: str, func: Callable, x: int, y: int, r: int, funcparam):</code></p>
<p>Apply a user provided function with parameters
to a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x,y)
                     and radius r
    func           : user defined
                     function
    funcparam      : parameters of
                     the function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usenopar24btfn2circreg"><code>_usenopar24btfn2circreg</code></a></h3>
<p><code>py
def _usenopar24btfn2circreg(bmp: array.array, x: int, y: int, r: int, func: Callable):</code></p>
<p>Apply a no parameter function
to a circular region with
center at (x, y) and a radius r
in a 24-bit bitmap</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the circular area
    func   : function to apply

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usenoparclradjfn"><code>_usenoparclradjfn</code></a></h3>
<p><code>py
def _usenoparclradjfn(ExistingBMPfile: str, NewBMPfile: str, func: Callable):</code></p>
<p>Apply a user provided no parameter color
    adjustment function to an existing bitmap</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    func           : user defined
                     function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._usenoparfn2circreg"><code>_usenoparfn2circreg</code></a></h3>
<p><code>py
def _usenoparfn2circreg(bmp: array.array, x: int, y: int, r: int, func: Callable):</code></p>
<p>Apply a no parameter function
to a circular region with a
center at (x,y) and a radius r</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x,y)
             and radius r
             of the
             circular area
    func   : function
             to apply
             to the area

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._xbytes"><code>_xbytes</code></a></h3>
<p><code>py
def _xbytes(x: int, bits: int) -&gt; int:</code></p>
<p>Get the number of bytes in
a bmp row given x dimension and bit depth</p>
<pre><code>Args:
    x   : unsigned int value of
          x-dimension
    bits: unsigned int value of
          bit depth (1, 4, 8, 24)

Returns:
    int value of number of bytes in a row
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib._xchrcnt"><code>_xchrcnt</code></a></h3>
<p><code>py
def _xchrcnt(bmp: array.array) -&gt; int:</code></p>
<p>Get the chars or bytes in row of a BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    count of bytes or
    chars in a row (x dim)
</code></pre>
<h3><a href="#Python_BMP.mathlib.addvect"><code>addvect</code></a></h3>
<p><code>py
def addvect(u: list[numbers.Number], v: list[numbers.Number]) -&gt; list[numbers.Number]:</code></p>
<p>Add vectors u and v by adding their components</p>
<pre><code>Args:
    u, v: list of ints or floats

Returns:
    list of ints or floats
</code></pre>
<h3><a href="#Python_BMP.mathlib.addvectinlist"><code>addvectinlist</code></a></h3>
<p><code>py
def addvectinlist(vlist: list[list[numbers.Number]]) -&gt; numbers.Number:</code></p>
<p>Gets the sum of the vectors in a list of vectors</p>
<pre><code>Args:
    vlist: list of vectors

Returns:
    list or vector
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.adjustbrightness2file"><code>adjustbrightness2file</code></a></h3>
<p><code>py
def adjustbrightness2file(ExistingBMPfile: str, NewBMPfile: str, percentadj: float):</code></p>
<p>Apply a brightness adjustment to the image in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    percentadj     : can be a
                     positive or
                     negative value
                     (signed float)

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.adjustbrightnessinregion2file"><code>adjustbrightnessinregion2file</code></a></h3>
<p><code>py
def adjustbrightnessinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, percentadj: float):</code></p>
<p>Brightness adjustment to rectangular area in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    percentadj     : can be a
                     positive or
                     negative
                     adjustment
                    (signed float)

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.adjustcolordicttopal"><code>adjustcolordicttopal</code></a></h3>
<p><code>py
def adjustcolordicttopal(bmp: array.array, colordict: dict):</code></p>
<p>Adjust a color dictionary to match
as closely as possible a bitmap palette</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    colordict: dictionary of colors

Returns:
    byref modified dictionary of colors
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.adjustthresholdinregion2file"><code>adjustthresholdinregion2file</code></a></h3>
<p><code>py
def adjustthresholdinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, lumrange: list):</code></p>
<p>Threshold adjust in a rectangular area in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    lumrange       : (byte:byte)
                     threshold to
                     apply

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.bufresize.adjustxbufsize"><code>adjustxbufsize</code></a></h3>
<p><code>py
def adjustxbufsize(bmp: array.array, x1: int, x2: int) -&gt; int:</code></p>
<p>Returns a 32 -bit padded
    int buffer size for a
    buffer with the bit depth
    stored in byte number 28
    of the bitmap bmp and an
    int length of x2 - x1 + 1</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    x1, x2: int params for
            a x coord line
            in the bitmap

Returns:
    int adjusted buffer size
</code></pre>
<h3><a href="#Python_BMP.mathlib.andvect"><code>andvect</code></a></h3>
<p><code>py
def andvect(u: list[int], v: list[int]) -&gt; list[int]:</code></p>
<p>Bitwise and operation of between
the elements of two lists of ints</p>
<pre><code>Args:
    v      : list[int]
    bitmask: int

Returns:
    list[int]
</code></pre>
<h3><a href="#Python_BMP.mathlib.anglebetween2Dlines"><code>anglebetween2Dlines</code></a></h3>
<p><code>py
def anglebetween2Dlines(u: list[numbers.Number, numbers.Number], v: list[numbers.Number, numbers.Number]) -&gt; float:</code></p>
<p>Compute the angle between two lines of vectors</p>
<pre><code>Args:
    u, v: list[Number, Number]

Returns:
    float angle in radians
</code></pre>
<h3><a href="#Python_BMP.colors.applybrightnessadjtoBGRbuf"><code>applybrightnessadjtoBGRbuf</code></a></h3>
<p><code>py
def applybrightnessadjtoBGRbuf(buf: array.array, percentadj: float) -&gt; array.array:</code></p>
<p>Apply a brightness adjustment
    to a BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    percentadj: float brightness
                adjust can be
                positive or
                negative

Returns:
    unsigned byte array
    holding brightness adjusted
    BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.applycolorfiltertoBGRbuf"><code>applycolorfiltertoBGRbuf</code></a></h3>
<p><code>py
def applycolorfiltertoBGRbuf(buf: array.array, rgbfactors: list[float, float, float]):</code></p>
<p>Apply a color filter to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    rgbfactors: color filter as
                  [r: float,
                   g: float,
                   b: float]

Returns:
    byref unsigned byte array
    holding color BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.applygammaBGRbuf"><code>applygammaBGRbuf</code></a></h3>
<p><code>py
def applygammaBGRbuf(buf: array.array, gamma: float):</code></p>
<p>Apply a gamma adjustment to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    gamma: float gamma adjust

Returns:
    byref unsigned byte array
    holding gamma adjusted
    BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.applymonochromefiltertoBGRbuf"><code>applymonochromefiltertoBGRbuf</code></a></h3>
<p><code>py
def applymonochromefiltertoBGRbuf(buf: array.array):</code></p>
<p>Apply a monochrome filter to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    rgbfactors: color filter as
                  [r: float,
                   g: float,
                   b: float]

Returns:
    byref unsigned byte array
    holding mono BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.applythresholdadjtoBGRbuf"><code>applythresholdadjtoBGRbuf</code></a></h3>
<p><code>py
def applythresholdadjtoBGRbuf(buf: array.array, lumrange: list) -&gt; array.array:</code></p>
<p>Apply a threshold adjustment
    to a BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    lumrange: [min: int, max: int]
              brightness threshold

Returns:
    unsigned byte array
    holding threshold adjusted
    BGR data
</code></pre>
<h3><a href="#Python_BMP.primitives2D.arcvert"><code>arcvert</code></a></h3>
<p><code>py
def arcvert(x: int, y: int, r: int, startdegangle: float, enddegangle: float):</code></p>
<p>Returns a list[(int, int)] of 2D vertices
along a path defined by radius r as it
traces an arc with origin set at (x, y)</p>
<pre><code>Args:
    x, y: int centerpoint
              coordinates
    r   : int radius

    startangle: degree start of arc
    endangle  : degree end of arc

Yields:
    list of vertices of the arc
    list[[x: int, y: int]]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.autocropimg2file"><code>autocropimg2file</code></a></h3>
<p><code>py
def autocropimg2file(ExistingBMPfile: str, NewBMPfile: str, similaritythreshold: float):</code></p>
<p>Perform an auto crop to the image in a bitmap file</p>
<pre><code>Args:
    ExistingBMPfile    : Whole path to
                         existing file
    NewBMPfile         : New file to
                         save changes in
    similaritythreshold: used to tune
                         autocrop

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.beziercurve"><code>beziercurve</code></a></h3>
<p><code>py
def beziercurve(bmp: array.array, pntlist: list[list[numbers.Number, numbers.Number]], penradius: int, color: int):</code></p>
<p>Draws a Bezier Curve</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    pntlist  : [(x,y)...]
               the control points
    penradius: radius of pen
    color    : color of the
               bezier curve

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.BMPbitBLTget"><code>BMPbitBLTget</code></a></h3>
<p><code>py
def BMPbitBLTget(bmp: array.array, offset: int, bufsize: int) -&gt; array.array:</code></p>
<p>Gets [offset: offset + bufsize] to a new array</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    offset : unsigned int
             address in buffer
    bufsize: unsigned int
             size of buffer

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.BMPbitBLTput"><code>BMPbitBLTput</code></a></h3>
<p><code>py
def BMPbitBLTput(bmp: array.array, offset: int, arraybuf: array.array):</code></p>
<p>Sets offset in array to arraybuf</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    offset  : unsigned int
              address in buffer
    arraybuf: unsigned byte array

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.bottomrightcoord"><code>bottomrightcoord</code></a></h3>
<p><code>py
def bottomrightcoord(bmp: array.array) -&gt; tuple:</code></p>
<p>Gets the maximum bottom right coordinates of a bmp</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    tuple (x:int,y:int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.brightnessadjcircregion2file"><code>brightnessadjcircregion2file</code></a></h3>
<p><code>py
def brightnessadjcircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, percentadj: float):</code></p>
<p>Brightness gradient to a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
                     of a circular
                     region
                     in which we
                     apply a
    percentadj     : brightness
                     adjustment
                     that can be
                     positive
                     or negative

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.brightnessadjcircregion"><code>brightnessadjcircregion</code></a></h3>
<p><code>py
def brightnessadjcircregion(bmp: array.array, x: int, y: int, r: int, percentadj: float):</code></p>
<p>Brightness adjustment to a circular area</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y, r   : center (x, y)
                and radius r
                of the region
    percentadj: float percent of the
                brightness adjustment

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.colors.brightnessadjust"><code>brightnessadjust</code></a></h3>
<p><code>py
def brightnessadjust(rgb: list[int, int, int], percentadj: float) -&gt; list[int, int, int]:</code></p>
<p>Apply a brightness adjustment
    to a rgb</p>
<pre><code>Args:
    rgb: color as [r: byte,
                   g: byte,
                   b: byte]
    percentadj: brightness
                adjustment
                in percent
                can be positive
                or negative

Returns:
    a brightness adjusted color as
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.brightnesseadjto24bitimage"><code>brightnesseadjto24bitimage</code></a></h3>
<p><code>py
def brightnesseadjto24bitimage(bmp: array.array, percentadj: float):</code></p>
<p>Brightness adjustment to a whole BMP</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    percentadj: float percentage
                brightness
                adjustment
                can be positive
                or negative

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.brightnesseadjto24bitregion"><code>brightnesseadjto24bitregion</code></a></h3>
<p><code>py
def brightnesseadjto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, percentadj: float):</code></p>
<p>Brightness adjustment to a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines
                    the rectangle
    percentadj    : float percentage
                    brightness adjust
                    can be positive
                    or negative

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.bspline"><code>bspline</code></a></h3>
<p><code>py
def bspline(bmp: array.array, pntlist: list, penradius: int, color: int, isclosed: bool, curveback: bool):</code></p>
<p>Draws a Bspline</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    pntlist  : [(x, y)...]
               the control points
    penradius: radius of pen
    color    : color of curve
    isclosed : True means the
               curve is closed
    curveback: True means
               extra computation
               for curve to loop
               back on itself

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.bsplinevert"><code>bsplinevert</code></a></h3>
<p><code>py
def bsplinevert(pntlist: list[list[int, int]], isclosed: bool, curveback: bool) -&gt; list[list[int, int]]:</code></p>
<p>Creates a list of vertices for a bspline curve</p>
<pre><code>Args:
    pntlist: 2D control points
             for the bspline curve
             as list[list[x: int,
                          y: int]]

Returns:
    list of vertices as
    list[list[x: int, y: int]]
</code></pre>
<h3><a href="#Python_BMP.inttools.buf2int"><code>buf2int</code></a></h3>
<p><code>py
def buf2int(buf: array.array) -&gt; int:</code></p>
<p>Converts an unsigned byte array
    to an integer value</p>
<pre><code>Args:
    buf: unsigned byte array

Returns:
    unsigned int value
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.centercoord"><code>centercoord</code></a></h3>
<p><code>py
def centercoord(bmp: array.array) -&gt; tuple:</code></p>
<p>Gets the central coordinates of a BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    tuple (x:int,y:int)
</code></pre>
<h3><a href="#Python_BMP.mathlib.centerpoint"><code>centerpoint</code></a></h3>
<p><code>py
def centerpoint(x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Returns the centerpoint x, y in rectangular area</p>
<pre><code>Args:
    x1, y1 : defines the
    x2, y2   rectangular area

Returns:
    x: int, y: int centerpoint
</code></pre>
<h3><a href="#Python_BMP.chartools.char2int"><code>char2int</code></a></h3>
<p><code>py
def char2int(charcodestr: str) -&gt; int:</code></p>
<p>Packs a string into an int
    using ascii code</p>
<pre><code>Args:
    charcodestr: string

Yields:
    int value
</code></pre>
<h3><a href="#Python_BMP.fileutils.checklink"><code>checklink</code></a></h3>
<p><code>py
def checklink(func: Callable):</code></p>
<p>Decorator to test if the first
    parameter in a function is
    a valid file</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.fileutils.checklinks"><code>checklinks</code></a></h3>
<p><code>py
def checklinks(func: Callable):</code></p>
<p>Decorator to test if the two
    parameters in a function
    are valid files</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.circle2file"><code>circle2file</code></a></h3>
<p><code>py
def circle2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, color: int):</code></p>
<p>Draws a Circle</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r
    color          : color of circle

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.circle"><code>circle</code></a></h3>
<p><code>py
def circle(bmp: array.array, x: int, y: int, r: int, color: int, isfilled: bool = None):</code></p>
<p>Draws a Circle</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y, r : center (x,y)
              and radius r
              of the circle
    color   : color of the circle
    isfilled: toggles if the
              circle is filled
              True -&gt; filled circle
              False -&gt; circle outline

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.circleinvolutevert"><code>circleinvolutevert</code></a></h3>
<p><code>py
def circleinvolutevert(x: int, y: int, a: float, delta: float, lim: float):</code></p>
<p>Returns (int, int) 2D vertices
along a path defined by the involute
of a circle with scaling factor a
and an origin set at (x, y)</p>
<pre><code>The involute of a circle is the path
traced out by a point on a straight
line that rolls around a circle.

It was studied by Huygens when he was
considering clocks without pendulums
that might be used on ships at sea.

Args:
    x, y : center of the curve
    a    : scaling factor
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    The vertices of the
    involute of a circle in a list
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.circlevec"><code>circlevec</code></a></h3>
<p><code>py
def circlevec(bmp: array.array, v: list, r: int, color: int, isfilled: bool = None):</code></p>
<p>Draws a circle</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    v       : (x, y) center of
              the circular region
    r       : radius of the
              circular region
    color   : color of the circle
    isfilled: toggles if the
              circle is filled

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfilter2file"><code>colorfilter2file</code></a></h3>
<p><code>py
def colorfilter2file(ExistingBMPfile: str, NewBMPfile: str, rgbfactors: list[float, float, float]):</code></p>
<p>Applies Color Filter rgbfactors to a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    rgbfactors     : (r,g,b) r, g, b
                     values range
                     from 0.0 to 1.0

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.colorfilter"><code>colorfilter</code></a></h3>
<p><code>py
def colorfilter(rgb: list[int, int, int], rgbfactors: list[float, float, float]) -&gt; list[int, int, int]:</code></p>
<p>Apply a color filter
    rgbfactors to rgb</p>
<pre><code>Args:
    rgb: color as [r: byte,
                   g: byte,
                   b: byte]

    rgbfactors: color filter as
                  [r: float,
                   g: float,
                   b: float]

Returns:
    a color filtered
    color as [r: byte,
              g: byte,
              b: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfiltercircregion2file"><code>colorfiltercircregion2file</code></a></h3>
<p><code>py
def colorfiltercircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>Applies a color filter to a circular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
    rgbfactors     : (r, g, b) values
                     range from 0 to 1

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfiltercircregion"><code>colorfiltercircregion</code></a></h3>
<p><code>py
def colorfiltercircregion(bmp: array.array, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>Color Filter to a circular area</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y, r   : center (x, y)
                and radius r
                of the region
    rgbfactors: [r, g, b] range of
                r, g and b are from
                0.0 min to 1.0 max

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfilterinregion2file"><code>colorfilterinregion2file</code></a></h3>
<p><code>py
def colorfilterinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, rgbfactors: list[float, float, float]):</code></p>
<p>Color Filter to a Rectangular Area in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    rgbfactors     : (r,g,b)
                     values range
                     from
                     0.0 to 1.0

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfilterto24bitimage"><code>colorfilterto24bitimage</code></a></h3>
<p><code>py
def colorfilterto24bitimage(bmp: array.array, rgbfactors: list[float, float, float]):</code></p>
<p>Applies a color filter
    to a whole image in
    an in-memory 24 bit bitmap</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    rgbfactors: color filter
                r,g and b values
                are from 0.0 to 1.0

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorfilterto24bitregion"><code>colorfilterto24bitregion</code></a></h3>
<p><code>py
def colorfilterto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, rgbfactors: list[float, float, float]):</code></p>
<p>Applies a color filter to
    a rectangular area defined
    by (x1, y1) and (x2, y2)
    in a 24-bit bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    rgbfactors    : color filter
                    r, g and b
                    range from
                    0.0 to 1.0

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.colors.colorfiltertoBGRbuf"><code>colorfiltertoBGRbuf</code></a></h3>
<p><code>py
def colorfiltertoBGRbuf(buf: array.array, rgbfactors: list[float, float, float]) -&gt; array.array:</code></p>
<p>Apply a color filter to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    rgbfactors: color filter as
                  [r: float,
                   g: float,
                   b: float]

Returns:
    unsigned byte array
    holding color BGR data
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.colorhistorgram"><code>colorhistorgram</code></a></h3>
<p><code>py
def colorhistorgram(bmp: array.array) -&gt; list:</code></p>
<p>Creates a color histogram</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    list sorted in descending order of color frequencies
</code></pre>
<h3><a href="#Python_BMP.colors.colormix"><code>colormix</code></a></h3>
<p><code>py
def colormix(lum: int, RGBfactors: list[float, float, float]) -&gt; int:</code></p>
<p>Mix a byte luminosity value to
    an rgb triplet that express
    a color value in [r, g, b]
    ratios from 0.0 to 1.0 to
    obtain an int value for a
    specific color</p>
<pre><code>Args:
    lum       : a byte value for
                luminosity
    RGBfactors: list[r: float,
                     g: float,
                     b: float]
                float values from
                0.0 to 1.0

Returns:
    int color val
</code></pre>
<h3><a href="#Python_BMP.solids3D.conevertandsurface"><code>conevertandsurface</code></a></h3>
<p><code>py
def conevertandsurface(vcen: list[float, float, float], r: float, zlen: float, deganglestep: float) -&gt; tuple:</code></p>
<p>Returns a list of sparse
    vertices and tiled surfaces
    for a cone</p>
<pre><code>Args:
    vcen       : [x: float, center
                  y: float, of the
                  z: float] sphere
    r           : radius of
                  conical base
    zlen        : height of
                  the cone
    deganglestep: angle step between
    vertices that controls how sparse
    the list will be

Returns:
    list of vertices and surfaces
    for plot3Dsolid()
    see Hello_Cone.py
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.convertbufto24bit"><code>convertbufto24bit</code></a></h3>
<p><code>py
def convertbufto24bit(buf: array.array, bgrpalbuf: array.array, bits: int) -&gt; array.array:</code></p>
<p>Converts 1, 4 and 8-bit buffers to a BGR buffer</p>
<pre><code>Args:
    buf      : unsigned byte array
    bgrpalbuf: BGR palette info
    bits     : color depth
               (1, 4, 8)

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.convertselection2BMP"><code>convertselection2BMP</code></a></h3>
<p><code>py
def convertselection2BMP(buf: array.array):</code></p>
<p>Converts custom unsigned byte array to bmp format</p>
<pre><code>Args:
    buf: unsigned byte array

Returns:
    unsigned byte array with bmp format
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copyBMPhdr"><code>copyBMPhdr</code></a></h3>
<p><code>py
def copyBMPhdr(bmp: array.array) -&gt; array.array:</code></p>
<p>Copies the bitmap header of an in-memory bmp
to a new unsigned byte array</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    unsigned byte array with bmp format
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.CopyBMPxydim2newBMP"><code>CopyBMPxydim2newBMP</code></a></h3>
<p><code>py
def CopyBMPxydim2newBMP(bmp: array.array, newbits: int) -&gt; array.array:</code></p>
<p>Creates a new bitmap with the same dimensions as bmp</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    newbits: bit depth
             (1, 4, 8, 24)

Returns:
    unsigned byte array with bitmap layout
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copycircregion2buf"><code>copycircregion2buf</code></a></h3>
<p><code>py
def copycircregion2buf(bmp: array.array, x: int, y: int, r: int) -&gt; list:</code></p>
<p>Copies a circular region to a
buffer which is defined by
centerpoint at (x, y) and radius r</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y, r : center (x, y)
              and radius r
              of the circular area

Returns:
    list with buffer of circular region
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copycircregion2file"><code>copycircregion2file</code></a></h3>
<p><code>py
def copycircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, newxycenterpoint: list):</code></p>
<p>Copy/Paste of a circular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile : Whole path
                      to existing file
    NewBMPfile      : New file to
                      save changes to
    x, y, r         : center (x,y)
                      and radius r
    newxycenterpoint: (x:int,y:int)
                      where to paste

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copycircregion"><code>copycircregion</code></a></h3>
<p><code>py
def copycircregion(bmp: array.array, x: int, y: int, r: int, newxy: list):</code></p>
<p>Copy a circular buffer with center at (x, y)
and a radius r to a new area with centerpoint at
newxy [x, y]</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the
             circular region
    newxy :  center of
             circular area
             to paste
             the buffer into

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copyrect"><code>copyrect</code></a></h3>
<p><code>py
def copyrect(bmp: array.array, x1: int, y1: int, x2: int, y2: int) -&gt; array.array:</code></p>
<p>Copy a rectangular region to a custom buffer</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    custom unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.copyRGBpal"><code>copyRGBpal</code></a></h3>
<p><code>py
def copyRGBpal(sourceBMP: array.array, destBMP: array.array):</code></p>
<p>Copies the RGB palette info from
a source unsigned byte array to
a destination unsigned byte array</p>
<pre><code>Args:
    sourceBMP and destBMP are both
    unsigned byte arrays with bmp format

Returns:
    byref modified destBMP
    (unsigned byte array)
</code></pre>
<h3><a href="#Python_BMP.mathlib.cosaffin"><code>cosaffin</code></a></h3>
<p><code>py
def cosaffin(u: list[numbers.Number], v: list[numbers.Number]) -&gt; float:</code></p>
<p>Compute Cosine Similarity or Cosine Affinity</p>
<pre><code>Args:
    u, v : list of ints or floats

Returns:
    float value
        proportional vectors = 1
        orthogonal vectors = 0
        opposite vectors = -1
        and values in between
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.crop"><code>crop</code></a></h3>
<p><code>py
def crop(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Crops the image to a rectangular
    region defined by (x1, y1)
                  and (x2, y2)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    region

Returns:
    unsigned byte array
    with bitmap layout
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.cropBMPandsave"><code>cropBMPandsave</code></a></h3>
<p><code>py
def cropBMPandsave(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Crops and saves a rectangular area to a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to an
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x1, y1, x2, y2 : the rectagular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.cropBMPandsaveusingrectbnd"><code>cropBMPandsaveusingrectbnd</code></a></h3>
<p><code>py
def cropBMPandsaveusingrectbnd(ExistingBMPfile: str, NewBMPfile: str, rectbnd: list):</code></p>
<p>Crops and saves a rectangular area to a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to existing file
    NewBMPfile     : New file to
                     save changes in
    rectbnd        : list defining
                     a rectangular
                     region
                     [(x1, y1),
                      (x2, y2),
                      (x3, y3),
                      (x4, y4)]

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.solids3D.cubevert"><code>cubevert</code></a></h3>
<p><code>py
def cubevert(x: float) -&gt; list[list[float, float, float]]:</code></p>
<p>Returns a list of vertices
    for a cube</p>
<pre><code>Args:
    x: length of a side

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.solids3D.cylindervertandsurface"><code>cylindervertandsurface</code></a></h3>
<p><code>py
def cylindervertandsurface(vcen: list[float, float, float], r: float, zlen: float, deganglestep: float) -&gt; tuple:</code></p>
<p>Returns a list of sparse vertices
   and tiled surfaces for a cylinder</p>
<pre><code>Args:
    vcen       : [x: float, center
                  y: float, of the
                  z: float] sphere
    r           : radius
    zlen        : height of the
                  cylinder
    deganglestep: angle step between
    vertices that controls how sparse
    the list will be

Returns:
    list of vertices and surfaces
    for plot3Dsolid()
    see Hello_Coin.py
</code></pre>
<h3><a href="#Python_BMP.solids3D.decahedvertandsurface"><code>decahedvertandsurface</code></a></h3>
<p><code>py
def decahedvertandsurface(x: float) -&gt; list[list[float, float, float]]:</code></p>
<p>Returns a list of vertices
    for a decahedron</p>
<pre><code>Args:
    x: min radius of sphere
       that can hold
       the decahedron

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.dicttools.dict2descorderlist"><code>dict2descorderlist</code></a></h3>
<p><code>py
def dict2descorderlist(d: dict) -&gt; list:</code></p>
<p>Creates a sorted list in
    decending order from
    a dictionary with counts</p>
<pre><code>Args:
    dict: histogram or
          frequency count

Returns:
    list
</code></pre>
<h3><a href="#Python_BMP.mathlib.distance"><code>distance</code></a></h3>
<p><code>py
def distance(u: list[float], v: list[float]) -&gt; float:</code></p>
<p>Compute the Distance or length of a vector v
of arbitrary dimension n in a n-dimensional
Euclidean space where u and v are both vectors
with n components</p>
<pre><code>Args:
    u, v: list of ints or floats

Returns:
    float
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.drawarc"><code>drawarc</code></a></h3>
<p><code>py
def drawarc(bmp: array.array, x: int, y: int, r: int, startdegangle: float, enddegangle: float, color: int, showoutline: bool, fillcolor: int, isfilled: bool):</code></p>
<p>Draws an Arc</p>
<pre><code>Args:
    bmp        : unsigned
                 byte array
                 with bmp format
    x, y, r    : defines a circle
                 that contains
                 the arc
    color      : color of arc
    showoutline: True -&gt; draw arc
                         outline
    fillcolor  : color of arc
                 filling
    isfilled   : True -&gt; set area
                         inside the
                         arc to
                         fillcolor

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.drawvec"><code>drawvec</code></a></h3>
<p><code>py
def drawvec(bmp: array.array, u: list, v: list, headsize: int, color: int, penradius: int = None):</code></p>
<p>Draws a vector (line segment with arrow head)</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    u        : (x: float, y: float)
                point 1 origin
    v        : (x: float, y: float)
               point 2 has arrow
    headsize : size of the arrow
               0 for default size
    color    : color of the vector
    penradius: optional parameter
               for thick arrow

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.ellipse"><code>ellipse</code></a></h3>
<p><code>py
def ellipse(bmp: array.array, x: int, y: int, b: int, a: int, color: int, isfilled: bool = None):</code></p>
<p>Draws an Ellipse</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y    : center of ellipse
    b, a    : major amd minor axis
    color   : color of the ellipse
    isfilled: True -&gt; filled
                      ellipse
              False-&gt; one pixel
                      thick
                      ellipse

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.ellipsevert"><code>ellipsevert</code></a></h3>
<p><code>py
def ellipsevert(x: int, y: int, b: int, a: int) -&gt; list[int, int]:</code></p>
<p>Returns (int, int) 2D vertices
along a path defined by major and
minor axes b and a as it traces
an ellipse with origin set at (x, y)</p>
<pre><code>Args:
    x, y: center of the ellipse
    b, a: major and minor axes

Returns:
    The list vertices of an
    ellipse
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.paramchecks.entirecircleinboundary"><code>entirecircleinboundary</code></a></h3>
<p><code>py
def entirecircleinboundary(func):</code></p>
<p>Decorator to ensure that the 2nd,
    3rd, 4th parameters are ints
    whose values when interpreted
    as the centerpoint x, y
    and radius r of a circle
    lay within the RGB bitmap.</p>
<pre><code>Args:
    function(bmp:array,x:int,y:int,r:int...)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.primitives2D.entirecircleisinboundary"><code>entirecircleisinboundary</code></a></h3>
<p><code>py
def entirecircleisinboundary(x: int, y: int, minx: int, maxx: int, miny: int, maxy: int, r: int):</code></p>
<p>Checks if an entire circle
is within a rectagular area</p>
<pre><code>Args:
    x, y: center of the ellipse
    xmin, ymin: min (x, y) bounds
    xmax, ymax: max (x, y) bounds
    r   : radius of the circle

Returns:
    boolean value
    True  -&gt; All (x, y)
             is in bounds
    False -&gt; Not all (x, y)
             is in bounds
</code></pre>
<h3><a href="#Python_BMP.primitives2D.entireellipseisinboundary"><code>entireellipseisinboundary</code></a></h3>
<p><code>py
def entireellipseisinboundary(x: int, y: int, minx: int, maxx: int, miny: int, maxy: int, b: int, a: int):</code></p>
<p>Checks if an entire ellipse
is within a rectagular area</p>
<pre><code>Args:
    x, y: center of the ellipse
    xmin, ymin: min (x, y) bounds
    xmax, ymax: max (x, y) bounds
    b, a: major and minor axes

Returns:
    boolean value
    True  -&gt; All (x, y)
             is in bounds
    False -&gt; Not all (x, y)
             is in bounds
</code></pre>
<h3><a href="#Python_BMP.paramchecks.entirerectinboundary"><code>entirerectinboundary</code></a></h3>
<p><code>py
def entirerectinboundary(func):</code></p>
<p>Decorator to ensure that the
    2nd, 3rd, 4th and 5th
    parameters are ints whose
    values when interpreted as
    x and y coordinates of a
    rectangle lay within the
    bitmap.</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.mathlib.enumbits"><code>enumbits</code></a></h3>
<p><code>py
def enumbits(byteval: int):</code></p>
<p>Yields the 8 bits in a byte</p>
<pre><code>Args:
    byteval: int value
             from 0 to 255

Yields:
    Eight bits that is either
    int 0 or int 1
</code></pre>
<h3><a href="#Python_BMP.chartools.enumletters"><code>enumletters</code></a></h3>
<p><code>py
def enumletters(st: str) -&gt; str:</code></p>
<p>Enumerates the characters
    in a string</p>
<pre><code>Args:
    st: string

Yields:
    individual characters
</code></pre>
<h3><a href="#Python_BMP.chartools.enumreverseletters"><code>enumreverseletters</code></a></h3>
<p><code>py
def enumreverseletters(st: str) -&gt; str:</code></p>
<p>Enumerates the characters in a
    string in reverse order</p>
<pre><code>Args:
    st: string

Yields:
    individual characters
</code></pre>
<h3><a href="#Python_BMP.primitives2D.epicycloidvert"><code>epicycloidvert</code></a></h3>
<p><code>py
def epicycloidvert(x: int, y: int, a: float, b: float, delta: float, lim: float):</code></p>
<p>Returns (int, int) 2D vertices
along a path defined by epicycloid
traced by a circle of radius b which
rolls round a circle of radius a
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of epicycloid
    a    : radius of fixed circle
    b    : radius of rolling circle
    delta: angle increment in radians
    lim  : angle limit in radians

Returns:
    The vertices of an
    epicycloid in a list
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.erasealternatehorizontallines"><code>erasealternatehorizontallines</code></a></h3>
<p><code>py
def erasealternatehorizontallines(bmp: array.array, int_eraseeverynline: int, int_eraseNthline: int, bytepat: int):</code></p>
<p>Erase every nth line</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with
                         bmp format
    int_eraseeverynline: erase every
                         nth line
                         in the
                         region
    int_eraseNthline   : control
                         which line
                         every
                         n lines
                         to erase
    bytepat            : byte pattern
                         to overwrite
                         the erased
                         lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.erasealternatehorizontallinesincircregion"><code>erasealternatehorizontallinesincircregion</code></a></h3>
<p><code>py
def erasealternatehorizontallinesincircregion(bmp: array.array, x: int, y: int, r: int, int_eraseeverynline: int, int_eraseNthline: int, bytepat: int):</code></p>
<p>Erase every nth line
    in a circular region</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with bmp
                         format
    x, y, r            : (x, y)
                         centerpoint
                         and radius r
                         of the
                         circular area
    int_eraseeverynline: erase every
                         nth line
                         in the
                         circular
                         region
    int_eraseNthline   : control which
                         line every
                         n lines
                         to erase
    bytepat            : pattern to
                         overwrite
                         the erased
                         lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.erasealternatehorizontallinesinregion"><code>erasealternatehorizontallinesinregion</code></a></h3>
<p><code>py
def erasealternatehorizontallinesinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, int_eraseeverynline: int, int_eraseNthline: int, bytepat: int):</code></p>
<p>Erase every nth line in a rectangular region</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with bmp
                         format
    x1, y1, x2, y2     : ints that
                         defines the
                         rectangular
                         region
    int_eraseeverynline: erase every
                         nth line
                         in the region
    int_eraseNthline   : control which
                         line every
                         n lines
                         to erase
    bytepat            : pattern to
                         overwrite
                         the erased
                         lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhoriline2file"><code>eraseeverynthhoriline2file</code></a></h3>
<p><code>py
def eraseeverynthhoriline2file(ExistingBMPfile: str, NewBMPfile: str, n: int):</code></p>
<p>Erase every nth line</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to existing file
    NewBMPfile     : New file to
                     save changes in
    n              : erase every
                     nth line

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhorilineinccircregion2file"><code>eraseeverynthhorilineinccircregion2file</code></a></h3>
<p><code>py
def eraseeverynthhorilineinccircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, n: int):</code></p>
<p>Erase every nth horzontal line in a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
                     in which we
    n              : omit every
                     nth line

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhorilineinregion2file"><code>eraseeverynthhorilineinregion2file</code></a></h3>
<p><code>py
def eraseeverynthhorilineinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, n: int):</code></p>
<p>Erase every nth line in a rectangular region</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     an existing
                     file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    n              : erase every
                     nth line

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhorilineinregion"><code>eraseeverynthhorilineinregion</code></a></h3>
<p><code>py
def eraseeverynthhorilineinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, n: int):</code></p>
<p>Erase every nth line in a
    rectangular region</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    n             : erase every
                    nth line in the
                    rectangular area

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhorizontalline"><code>eraseeverynthhorizontalline</code></a></h3>
<p><code>py
def eraseeverynthhorizontalline(bmp: array.array, n: int):</code></p>
<p>Erase every nth horizontal line</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    n  : erase every nth line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.eraseeverynthhorizontallineinccircregion"><code>eraseeverynthhorizontallineinccircregion</code></a></h3>
<p><code>py
def eraseeverynthhorizontallineinccircregion(bmp: array.array, x: int, y: int, r: int, n: int):</code></p>
<p>Erase every nth horizontal line in a circular region</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the circular area
    n      : erase every nth line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fern2file"><code>fern2file</code></a></h3>
<p><code>py
def fern2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Fern Fractal in a bounding rectangle</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular region
    color          : color of the
                     fern fractal

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fern"><code>fern</code></a></h3>
<p><code>py
def fern(bmp: array.array, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Draws an IFS fern fractal</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: rectangular
                    area to draw
                    the fern in
    color         : color of the
                    fern fractal

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fillbackgroundwithgrad"><code>fillbackgroundwithgrad</code></a></h3>
<p><code>py
def fillbackgroundwithgrad(bmp: array.array, lumrange: list[int, int], RGBfactors: list[float, float, float], direction: int):</code></p>
<p>Fills entire bitmap with a linear gradient</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    lumrange  : [byte,byte] that
                define the range
                the of gradient
    RGBfactors: [r,g,b] each item
                in list are unsigned
                floats from 0 to 1
    direction : 0 - vertical
                1 - horizontal

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fillboundary"><code>fillboundary</code></a></h3>
<p><code>py
def fillboundary(bmp: array.array, bndfilldic: dict, color: int):</code></p>
<p>Draws lines in a boundary to fill it</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    bndfilldic: boundary dictionary
    color     : color of fill

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledcircle2file"><code>filledcircle2file</code></a></h3>
<p><code>py
def filledcircle2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, color: int):</code></p>
<p>Draws a Filled Circle</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
    color          : color of the
                     circular region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledcircle"><code>filledcircle</code></a></h3>
<p><code>py
def filledcircle(bmp: array.array, x: int, y: int, r: int, color: int):</code></p>
<p>Draws a Filled Circle</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of filled circle
    color  : color of the
             filled circle

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledellipse"><code>filledellipse</code></a></h3>
<p><code>py
def filledellipse(bmp: array.array, x: int, y: int, b: int, a: int, color: int):</code></p>
<p>Filled Ellipse</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    x, y : center of ellipse
    b, a : major amd minor axis
    color: color of the ellipse

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledgradrect"><code>filledgradrect</code></a></h3>
<p><code>py
def filledgradrect(bmp: array.array, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int], RGBfactors: list[float, float, float], direction: int):</code></p>
<p>Draw a filled rectangle with a linear gradient</p>
<pre><code>Args:
    bmp            : unsigned
                     byte array
                     with bmp format
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    lumrange       : [byte, byte]
                     defines
                     the range
                     of the
                     gradient
    RGBfactors     : [r, g, b] items
                     in list are
                     unsigned floats
                     from 0.0 to 1.0
    direction      : 0 - vertical
                     1 - horizontal

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledparallelogram"><code>filledparallelogram</code></a></h3>
<p><code>py
def filledparallelogram(bmp: array.array, p1: list, p2: list, p3: list, color: int):</code></p>
<p>Creates a filled parallelogram defined by 3 points</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    p1, p2, p3:(x: float, y: float)
                points that define
                a parallelogram
    color     : color of the
                filled parallelgram

Returns:
    byref unsigned modified byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.filledrect"><code>filledrect</code></a></h3>
<p><code>py
def filledrect(bmp: array.array, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Draws a Filled Rectangle</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    color         : color of the
                    rectangle

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.solids3D.fillpolydata"><code>fillpolydata</code></a></h3>
<p><code>py
def fillpolydata(polybnd: list[list[int, int]], xlim: int, ylim: int) -&gt; list:</code></p>
<p>Generates a list of x values per
    y values for filling polygon
    boundaries</p>
<pre><code>Args:
    polybnd : list of 2D vertices
              list[list[x: int,
                        y: int]]
              that forms a
              complete polygon
              boundary (see
              def polyboundary)
    xlim    : Screen limit x dim
    ylim    : Screen limit x dim

Returns:
    A dictionary with y values
    as key and list of x values
    per key (if within bounds)
    or an empty list if out of
    bounds
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphoricircregion2file"><code>fliphoricircregion2file</code></a></h3>
<p><code>py
def fliphoricircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Horizontal Flip of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x,y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphoricircregion"><code>fliphoricircregion</code></a></h3>
<p><code>py
def fliphoricircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Flips horizontally a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of circular region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphorizontal2file"><code>fliphorizontal2file</code></a></h3>
<p><code>py
def fliphorizontal2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Flips horizontally the image in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphorizontal"><code>fliphorizontal</code></a></h3>
<p><code>py
def fliphorizontal(bmp: array.array):</code></p>
<p>Does a horizontal flip of an
    in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphorizontalregion2file"><code>fliphorizontalregion2file</code></a></h3>
<p><code>py
def fliphorizontalregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Flips horizontally a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphorizontalregion"><code>fliphorizontalregion</code></a></h3>
<p><code>py
def fliphorizontalregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Does a horizontal flip
    of a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphorzontalpixelbased"><code>fliphorzontalpixelbased</code></a></h3>
<p><code>py
def fliphorzontalpixelbased(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Flips horizontal
    a rectangular region
    using pixel addressing
    (slightly slow)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.fliphverticalalpixelbased"><code>fliphverticalalpixelbased</code></a></h3>
<p><code>py
def fliphverticalalpixelbased(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Flips vertical
    a rectangular region
    using pixel addressing
    (slightly slow)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.bufferflip.flipnibbleinbuf"><code>flipnibbleinbuf</code></a></h3>
<p><code>py
def flipnibbleinbuf(buf: array.array) -&gt; array.array:</code></p>
<p>Flips a 4-bit image buffer</p>
<pre><code>Args:
    buf: unsigned byte array

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipvertcircregion2file"><code>flipvertcircregion2file</code></a></h3>
<p><code>py
def flipvertcircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Vertical Flip of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipvertcircregion"><code>flipvertcircregion</code></a></h3>
<p><code>py
def flipvertcircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Vertical Flip of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of a region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipvertical2file"><code>flipvertical2file</code></a></h3>
<p><code>py
def flipvertical2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Flips a bitmap file vertically</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipvertical"><code>flipvertical</code></a></h3>
<p><code>py
def flipvertical(bmp: array.array):</code></p>
<p>Does an vertical flip of a bmp</p>
<pre><code>Args:
    bmp: unsigned byte array
    with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipverticalregion2file"><code>flipverticalregion2file</code></a></h3>
<p><code>py
def flipverticalregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Flips vertically a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipverticalregion"><code>flipverticalregion</code></a></h3>
<p><code>py
def flipverticalregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Flips vertical a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipXY2file"><code>flipXY2file</code></a></h3>
<p><code>py
def flipXY2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Flips the x and y coordinates to rotate by 90 degrees</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipXY"><code>flipXY</code></a></h3>
<p><code>py
def flipXY(bmp: array.array):</code></p>
<p>Flips the x and y coordinates of
    an in-memory bitmap for a
    90 degree rotation</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipXYcircregion2file"><code>flipXYcircregion2file</code></a></h3>
<p><code>py
def flipXYcircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Flips the x and y coordinates of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.flipXYcircregion"><code>flipXYcircregion</code></a></h3>
<p><code>py
def flipXYcircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Flip the X and Y coordinates of a circular area</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y, r : center (x,y) and
              radius r of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.flowervert"><code>flowervert</code></a></h3>
<p><code>py
def flowervert(cx: int, cy: int, r: int, petals: int, angrot: float):</code></p>
<p>Returns a list of 2D points for a flower</p>
<pre><code>Args:
    cx, cy, r : center (cx,cy)
                and radius r
    petals    : number of petals
    angrot    : angle of rotation

Returns:
    list[(x: int, y: int)]
</code></pre>
<h3><a href="#Python_BMP.paramchecks.func24bitonly"><code>func24bitonly</code></a></h3>
<p><code>py
def func24bitonly(func):</code></p>
<p>Decorator to restrict the
    use of this function to only
    24-bit or RGB bitmaps
    (1st parameter)</p>
<pre><code>Args:
    function(bmp:array,...)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.paramchecks.func24bitonlyandentirecircleinboundary"><code>func24bitonlyandentirecircleinboundary</code></a></h3>
<p><code>py
def func24bitonlyandentirecircleinboundary(func):</code></p>
<p>Decorator to restrict the
    use of this function to only
    24-bit bitmaps (1st parameter)
    and ensure that the 2nd, 3rd,
    4th parameters are ints whose
    values when interpreted as
    x, y and radius of a circle
    lay within the RGB bitmap.</p>
<pre><code>Args:
    function(bmp:array,x:int,y:int,r:int...)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.paramchecks.func24bitonlyandentirerectinboundary"><code>func24bitonlyandentirerectinboundary</code></a></h3>
<p><code>py
def func24bitonlyandentirerectinboundary(func):</code></p>
<p>Decorator to restrict the
    use of this function to only
    24-bit or RGB bitmaps
    (1st parameter) and ensure that
    the 2nd, 3rd, 4th and 5th
    parameters are ints whose
    values when interpreted as
    x and y coordinates lay
    within the RGB bitmap.</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.paramchecks.func8and24bitonlyandentirecircleinboundary"><code>func8and24bitonlyandentirecircleinboundary</code></a></h3>
<p><code>py
def func8and24bitonlyandentirecircleinboundary(func):</code></p>
<p>Decorator to restrict the
    use of this function to only
    24-bit or 8-bit bitmaps
    (1st parameter) and ensure
    that the 2nd, 3rd, 4th
    parameters are ints whose
    values when interpreted as
    x, y and radius of a circle
    lay within the RGB bitmap.</p>
<pre><code>Args:
    function(bmp:array,x:int,y:int,r:int...)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.paramchecks.func8and24bitonlyandentirerectinboundary"><code>func8and24bitonlyandentirerectinboundary</code></a></h3>
<p><code>py
def func8and24bitonlyandentirerectinboundary(func):</code></p>
<p>Decorator to restrict the
    use of this functiom to only
    24 bit or 8 bit bitmaps
    (1st parameter) and ensure
    that the 2nd, 3rd, 4th and
    5th parameters are ints whose
    values when interpreted as
    x and y coordinates of a
    rectangle lay within
    the RGB bitmap.</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.proctimer.functimer"><code>functimer</code></a></h3>
<p><code>py
def functimer(func):</code></p>
<p>Function timer Decorator</p>
<pre><code>Args:
    function

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammaadj2file"><code>gammaadj2file</code></a></h3>
<p><code>py
def gammaadj2file(ExistingBMPfile: str, NewBMPfile: str, gamma: float):</code></p>
<p>Applies a Gamma Correction</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    gamma          : gamma
                     correction

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammaadjto24bitimage"><code>gammaadjto24bitimage</code></a></h3>
<p><code>py
def gammaadjto24bitimage(bmp: array.array, gamma: float):</code></p>
<p>Gamma correction to an in-memory 24-bit BMP</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    gamma: gamma correction

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammaadjto24bitregion"><code>gammaadjto24bitregion</code></a></h3>
<p><code>py
def gammaadjto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, gamma: float):</code></p>
<p>Gamma correction to a rectangular area in a 24-bit BMP</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    gamma         : gamma correction

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammaadjtoregion2file"><code>gammaadjtoregion2file</code></a></h3>
<p><code>py
def gammaadjtoregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, gamma: float):</code></p>
<p>Gamma Correction to a Rectangular Region</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    gamma          : gamma
                     correction

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.gammaBGRbuf"><code>gammaBGRbuf</code></a></h3>
<p><code>py
def gammaBGRbuf(buf: array.array, gamma: float) -&gt; array.array:</code></p>
<p>Apply a gamma adjustment to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    gamma: float gamma adjust

Returns:
    unsigned byte array
    holding gamma adjusted
    BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.gammacorrect"><code>gammacorrect</code></a></h3>
<p><code>py
def gammacorrect(rgb: list[int, int, int], gamma: float) -&gt; list[int, int, int]:</code></p>
<p>Apply a gamma factor to a rgb</p>
<pre><code>Args:
    rgb: color as [r: byte,
                   g: byte,
                   b: byte]
    gamma  : gamma adjustment

Returns:
    a gamma adjusted color as
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammacorrectcircregion2file"><code>gammacorrectcircregion2file</code></a></h3>
<p><code>py
def gammacorrectcircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, gamma: float):</code></p>
<p>Gamma Adjust to a circular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
                     of a circular
                     region
    gamma          : gamma
                     adjustment

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gammacorrectcircregion"><code>gammacorrectcircregion</code></a></h3>
<p><code>py
def gammacorrectcircregion(bmp: array.array, x: int, y: int, r: int, gamma: float):</code></p>
<p>Gamma correction to a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the region
    gamma  : float value of the
             gamma adjustment

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.charts.genpiechartdata"><code>genpiechartdata</code></a></h3>
<p><code>py
def genpiechartdata(dlist: list):</code></p>
<p>Preprocess data to make
    it suitable for a pie chart</p>
<pre><code>Args:
    dlist: [[20, c['red']],
            [30, c['brightyellow']],
            ...]

Returns:
    list and large value (if any)
</code></pre>
<h3><a href="#Python_BMP.solids3D.gensides"><code>gensides</code></a></h3>
<p><code>py
def gensides(pointlists: list[list, list], transvect: list[float, float, float], sides: list[list[float]]) -&gt; tuple:</code></p>
<p>Generates a list of polygons
and normals from 3D polygon
and side data to a list of
sides and normals with
with the hidden surfaces
removed that is suitable
for rendering on a 2D surface
and also applies a
3D translation vector for
positioning</p>
<h3><a href="#Python_BMP.BITMAPlib.getallRGBpal"><code>getallRGBpal</code></a></h3>
<p><code>py
def getallRGBpal(bmp: array.array) -&gt; list[list[int, int, int]]:</code></p>
<p>Gets the RGB palette of a bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    [(r: byte, g: byte, b: byte), ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getBGRpalbuf"><code>getBGRpalbuf</code></a></h3>
<p><code>py
def getBGRpalbuf(bmp: array.array):</code></p>
<p>Gets bitmap palette as stored in the bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    unsigned byte array (BGR)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getBMPimgbytes"><code>getBMPimgbytes</code></a></h3>
<p><code>py
def getBMPimgbytes(bmp: array.array) -&gt; list:</code></p>
<p>Gets the raw image buffer of a bmp without the header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    list of unsigned bytes
</code></pre>
<h3><a href="#Python_BMP.fonts.getcharfont"><code>getcharfont</code></a></h3>
<p><code>py
def getcharfont(charbuf: list, character: str) -&gt; list:</code></p>
<h3><a href="#Python_BMP.colordict.getcolorname2HSLdict"><code>getcolorname2HSLdict</code></a></h3>
<p><code>py
def getcolorname2HSLdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.colordict.getcolorname2RGBdict"><code>getcolorname2RGBdict</code></a></h3>
<p><code>py
def getcolorname2RGBdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.charts.getdatalisttotal"><code>getdatalisttotal</code></a></h3>
<p><code>py
def getdatalisttotal(dlist: list[numbers.Number]) -&gt; numbers.Number:</code></p>
<p>Returns the total of a
    list of ints or floats</p>
<pre><code>Args:
    dlist: list of ints or floats

Returns:
    float or int
</code></pre>
<h3><a href="#Python_BMP.colors.getdefaultbitpal"><code>getdefaultbitpal</code></a></h3>
<p><code>py
def getdefaultbitpal(bits: int) -&gt; list:</code></p>
<p>Gets the standard bitmap palette
    for a  specified bit depth bits</p>
<pre><code>Args:
    bits: int value (1, 4, 8, 24)

Returns:
    list of palette entries
</code></pre>
<h3><a href="#Python_BMP.colors.getdefaultlumrange"><code>getdefaultlumrange</code></a></h3>
<p><code>py
def getdefaultlumrange() -&gt; dict:</code></p>
<p>Gets the default luminosity
    ranges lookup</p>
<pre><code>Returns:
    a dict for default
    luminosity ranges
</code></pre>
<h3><a href="#Python_BMP.funcmeta.getfuncmetastr"><code>getfuncmetastr</code></a></h3>
<p><code>py
def getfuncmetastr(f: Callable):</code></p>
<h3><a href="#Python_BMP.fractals.getIFSparams"><code>getIFSparams</code></a></h3>
<p><code>py
def getIFSparams() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.BITMAPlib.getimagedgevert"><code>getimagedgevert</code></a></h3>
<p><code>py
def getimagedgevert(bmp: array.array, similaritythreshold: int):</code></p>
<p>Find edges in an image</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with bmp
                         format
    similaritythreshold: how close
                         to the color
                         before we
                         yield it

Yields:
    [(x: int, y: int),...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getimageregionbyRGB"><code>getimageregionbyRGB</code></a></h3>
<p><code>py
def getimageregionbyRGB(bmp: array.array, rgb: list[int, int, int], similaritythreshold: int):</code></p>
<p>Select a region by color</p>
<pre><code>Args:
    bmp                 :unsigned
                         byte array
                         with bmp
                         format
    rgb                 :(r: byte,
                          g: byte,
                          b: byte)
    similaritythreshold: controls
                         the edge
                         detection
                         sensitivity

Returns:
    list of vertices
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getmaxcolors"><code>getmaxcolors</code></a></h3>
<p><code>py
def getmaxcolors(bmp: array.array) -&gt; int:</code></p>
<p>Get the maximum number of colors supported by a BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    int value
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getmaxx"><code>getmaxx</code></a></h3>
<p><code>py
def getmaxx(bmp: array.array) -&gt; int:</code></p>
<p>Gets the x value stored in the windows bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    int value of x bmp dimension
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getmaxxy"><code>getmaxxy</code></a></h3>
<p><code>py
def getmaxxy(bmp: array.array) -&gt; tuple:</code></p>
<p>Gets the max x and y values stored in the bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    tuple (x:int,y:int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getmaxxyandbits"><code>getmaxxyandbits</code></a></h3>
<p><code>py
def getmaxxyandbits(bmp: array.array) -&gt; tuple:</code></p>
<p>Returns bitmap metadata
   (x-dimension, y-dimension, bit depth)</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    (x-dimension, y-dimension, bit depth)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getmaxy"><code>getmaxy</code></a></h3>
<p><code>py
def getmaxy(bmp: array.array) -&gt; int:</code></p>
<p>Gets the y value stored in the windows bmp header</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    int value of y bmp dimension
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getneighborcolorlist"><code>getneighborcolorlist</code></a></h3>
<p><code>py
def getneighborcolorlist(bmp: array.array, v: list):</code></p>
<h3><a href="#Python_BMP.colordict.getRGBfactors"><code>getRGBfactors</code></a></h3>
<p><code>py
def getRGBfactors() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.BITMAPlib.getRGBpal"><code>getRGBpal</code></a></h3>
<p><code>py
def getRGBpal(bmp: array.array, c: int) -&gt; list[int, int, int]:</code></p>
<p>Gets the [R, G, B] values
    of color c in a bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    c  : unsigned int color

Returns:
    [R: byte, G: byte, B:byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getRGBxybit"><code>getRGBxybit</code></a></h3>
<p><code>py
def getRGBxybit(bmp: array.array, x: int, y: int) -&gt; list[int, int, int]:</code></p>
<p>Gets [R:byte, G:byte, B:byte]
of pixel at (x, y) in a bitmap</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int
          locations in x and y

Returns:
    [R: byte, G: byte, B: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getRGBxybitvec"><code>getRGBxybitvec</code></a></h3>
<p><code>py
def getRGBxybitvec(bmp: array.array, v: list) -&gt; list:</code></p>
<p>Gets the RGB of a pixel at (x,y) in a BMP</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    v  : pixel location
         (x:int, y:int)

Returns:
    [R: byte, G: byte, B: byte]
</code></pre>
<h3><a href="#Python_BMP.solids3D.getshapesidedict"><code>getshapesidedict</code></a></h3>
<p><code>py
def getshapesidedict() -&gt; dict:</code></p>
<p>Returns a dictionary of side
    or polygon definitions for
    simple solids</p>
<pre><code>Returns:
    dictionary of side or polygon
    definitions for basic solids
</code></pre>
<h3><a href="#Python_BMP.X11colordict.getX11colorname2HSLdict"><code>getX11colorname2HSLdict</code></a></h3>
<p><code>py
def getX11colorname2HSLdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.X11colordict.getX11colorname2RGBdict"><code>getX11colorname2RGBdict</code></a></h3>
<p><code>py
def getX11colorname2RGBdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.X11colordict.getX11RGBfactors"><code>getX11RGBfactors</code></a></h3>
<p><code>py
def getX11RGBfactors() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.XKCDcolordict.getXKCDcolorname2HSLdict"><code>getXKCDcolorname2HSLdict</code></a></h3>
<p><code>py
def getXKCDcolorname2HSLdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.XKCDcolordict.getXKCDcolorname2RGBdict"><code>getXKCDcolorname2RGBdict</code></a></h3>
<p><code>py
def getXKCDcolorname2RGBdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.XKCDcolordict.getXKCDRGBfactors"><code>getXKCDRGBfactors</code></a></h3>
<p><code>py
def getXKCDRGBfactors() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.BITMAPlib.getxybit"><code>getxybit</code></a></h3>
<p><code>py
def getxybit(bmp: array.array, x: int, y: int) -&gt; int:</code></p>
<p>Gets color of pixel at (x, y) in a BMP</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int
          locations in x and y

Returns:
    unsigned int color value
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.getxybitvec"><code>getxybitvec</code></a></h3>
<p><code>py
def getxybitvec(bmp: array.array, v: list) -&gt; int:</code></p>
<p>Gets color of pixel at (x, y)</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    v  : (x: int, y: int)
         pixel coordinates

Returns:
    unsigned int color value
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradcircle"><code>gradcircle</code></a></h3>
<p><code>py
def gradcircle(bmp: array.array, x: int, y: int, r: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Filled Circle with Gradient</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y, r   : center (x, y)
                and radius r
    lumrange  : [byte,byte] range of
                the gradient
    rgbfactors: [r, g, b] range are
                from 0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradellipse"><code>gradellipse</code></a></h3>
<p><code>py
def gradellipse(bmp: array.array, x: int, y: int, b: int, a: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Ellipical gradient</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : center of ellipse
    b, a      : major amd minor axis
    lumrange  : [byte:byte] controls
                the range of the
                luminosity gradient
    rgbfactors: [r, g, b] range
                are from 0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradthickcircle"><code>gradthickcircle</code></a></h3>
<p><code>py
def gradthickcircle(bmp: array.array, x: int, y: int, r: int, penradius: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Thick Circle with a Gradient</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y, r   : center (x, y)
                and radius r
    penradius : radius of the
                round pen
    lumrange  : [byte,byte] range
                of the luminosity
                gradient
    rgbfactors: [r,g,b] range are
                from 0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradthickellipserot"><code>gradthickellipserot</code></a></h3>
<p><code>py
def gradthickellipserot(bmp: array.array, x: int, y: int, b: int, a: int, degrot: float, penradius: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Thick Ellipse with a Gradient fill</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : center of ellipse
    b, a      : major amd minor axis
    degrot    : rotation of
                the ellipse in degrees
    penradius : defines the
                thickness of the pen
    lumrange  : [byte:byte] sets
                the range of the
                luminosity gradient
    rgbfactors: [r, g, b] range are
                from 0.0 min to 1.0 max

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradthickplotpoly"><code>gradthickplotpoly</code></a></h3>
<p><code>py
def gradthickplotpoly(bmp: array.array, vertlist: list, penradius: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Draws a polygon of a given gradient and thickness</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    vertlist  : [(x,y)...] the
                list of vertices
    penradius : radius of pen
    lumrange  : [byte,byte] range
                of the gradient
    RGBfactors: [r, g, b] value
                range from
                0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradthickroundline"><code>gradthickroundline</code></a></h3>
<p><code>py
def gradthickroundline(bmp: array.array, p1: list, p2: list, penradius: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Draw a Thick Rounded Line with a Gradient</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    p1, p2   : (x, y) endpoints
                of the line
    penradius: radius of pen
    lumrange : list of two
               byte values
               [gradstart,gradend]
               that define the
               luminosity gradient
    RGBfactors: [r, g, b]
                each item
                in list is an
                unsigned float
                with a range
                from 0.0 to 1.0

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.gradvert"><code>gradvert</code></a></h3>
<p><code>py
def gradvert(bmp: array.array, vertlist: list[list[int, int]], penradius: int, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>List of 2d vertices as spheres of a given color</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    vertlist  : [(x, y), ...]
                list of vertices
    penradius : radius of
                the spheres
    lumrange  : [byte, byte] sets
                the luminosity
                gradient
    RGBfactors: (r, g, b)
                values range from
                min 0.0 to 1.0 max

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.solids3D.hexahedravert"><code>hexahedravert</code></a></h3>
<p><code>py
def hexahedravert(x: float) -&gt; list[list[float, float, float]]:</code></p>
<p>Returns a list of vertices
    for a hexahedron</p>
<pre><code>Args:
    x: length of a side

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horibrightnessgrad2circregion2file"><code>horibrightnessgrad2circregion2file</code></a></h3>
<p><code>py
def horibrightnessgrad2circregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Horizontal brightness gradient to a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
                     of a circular
                     region in which
                     we apply a
    lumrange       : brightness gradient
                     (byte, byte) adjust

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horibrightnessgrad2circregion"><code>horibrightnessgrad2circregion</code></a></h3>
<p><code>py
def horibrightnessgrad2circregion(bmp: array.array, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Horizontal brightness gradient adjustment to a circular area</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y, r : center (x, y)
              and radius r
              of a circular area
    lumrange: [byte, byte] the
              luminosity range

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horiline"><code>horiline</code></a></h3>
<p><code>py
def horiline(bmp: array.array, y: int, x1: int, x2: int, color: int):</code></p>
<p>Draw a Horizontal Line</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    y     : constant y value
            of the line
    x1    : starts at x1
    x2    : ends at x2
    color : color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horilinevert"><code>horilinevert</code></a></h3>
<p><code>py
def horilinevert(bmp: array.array, vlist: list[list[int, int]], linelen: int, xadj: int, color: int):</code></p>
<p>Horizontal line marks at vertices in vlist</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    vlist  : [(x, y), ...]
             the list of
             2D vertices
    linelen: length of the
             vertical lines
    xadj   : sets an adjustment
             for x coordinates
    color  : color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horitransformincircregion"><code>horitransformincircregion</code></a></h3>
<p><code>py
def horitransformincircregion(bmp: array.array, x: int, y: int, r: int, trans: str):</code></p>
<p>Horizontal transform to a circular area</p>
<pre><code>Args:
    bmp  :   unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r of region
    trans:   single letter
             transform code
             'L' -&gt; mirror left
             'R' -&gt; mirror right
             'F' -&gt; flip

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horizontalbrightnessgrad2file"><code>horizontalbrightnessgrad2file</code></a></h3>
<p><code>py
def horizontalbrightnessgrad2file(ExistingBMPfile: str, NewBMPfile: str, lumrange: list[int, int]):</code></p>
<p>Horizontal brightness gradient to a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    lumrange       : (byte:byte)
                     defines the
                     brightness
                     gradient

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horizontalbrightnessgradregion2file"><code>horizontalbrightnessgradregion2file</code></a></h3>
<p><code>py
def horizontalbrightnessgradregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int]):</code></p>
<p>Horizontal brightness gradient to a rectangular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2 ,y2 : defines the
                     rectangular
                     region
    lumrange       : (byte:byte)
                     brightness
                     gradient

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horizontalbrightnessgradto24bitimage"><code>horizontalbrightnessgradto24bitimage</code></a></h3>
<p><code>py
def horizontalbrightnessgradto24bitimage(bmp: array.array, lumrange: list[int, int]):</code></p>
<p>Applies a horizontal brightness
    gradient to a 24-bit bitmap</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    lumrange: [byte,byte]
              the range of the
              luminosity gradient

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horizontalbrightnessgradto24bitregion"><code>horizontalbrightnessgradto24bitregion</code></a></h3>
<p><code>py
def horizontalbrightnessgradto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int]):</code></p>
<p>Apply a horizontal brightness gradient
to a rectangular area in a 24-bit bitmap</p>
<pre><code>Args:
    bmp            : unsigned
                     byte array
                     with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    lumrange      : (byte: byte)
                    defines
                    the brightness
                    gradient

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.horizontalbulkswap"><code>horizontalbulkswap</code></a></h3>
<p><code>py
def horizontalbulkswap(bmp: array.array, x1: int, y1: int, x2: int, y2: int, swapfunc: Callable):</code></p>
<p>Applies function swapfunc
    to a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.horizontalvert"><code>horizontalvert</code></a></h3>
<p><code>py
def horizontalvert(y: int, x1: int, x2: int, dx: int) -&gt; list[list[int, int]]:</code></p>
<p>Creates a list of int vertices along
a horizontal line with int step dx</p>
<pre><code>Args:
    y : int constant y
    x1: int start point
    x2: int end point
    dx: int x step increment

Returns:
    list of int vertices
    [(x, y), ...]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.hypotrochoidvert"><code>hypotrochoidvert</code></a></h3>
<p><code>py
def hypotrochoidvert(x: int, y: int, a: float, b: float, c: float, delta: float, lim: float):</code></p>
<p>Returns (int, int) 2D vertices
along a path defined by a hypotrochoid
traced by a point with distance c from
the center of circle of radius b
which rolls round a circle of radius a
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of hypotrochoid
    a    : radius of fixed circle
    b    : radius of rolling circle
    c    : distance of pen from the
           center of circle with
           radius b
    delta: angle increment in radians
    lim  : angle limit in radians

Returns:
    The vertices of an
    hypotrochoid in a list
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.solids3D.icosahedvertandsurface"><code>icosahedvertandsurface</code></a></h3>
<p><code>py
def icosahedvertandsurface(x: float) -&gt; list[list[list[float, float, float]], tuple]:</code></p>
<p>Returns a list of vertices
    and surfaces for an icosahedron</p>
<pre><code>Args:
    x: min radius of sphere
       that can hold
       the icosahedron

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.IFS"><code>IFS</code></a></h3>
<p><code>py
def IFS(bmp: array.array, IFStransparam: tuple, x1: int, y1: int, x2: int, y2: int, xscale: int, yscale: int, xoffset: int, yoffset: int, color: int, maxiter: int):</code></p>
<p>Draw an Interated Function System Fractal</p>
<pre><code>Args:
    bmp            : unsigned
                     byte array
                     with bmp format
    IFStransparam  : see fractals.py
    x1, y1, x2, y2 : rectangular
                     region
                     to draw in
    xscale,yscale  : scaling factors
    xoffset,yoffset: used to move
                     the fractal
    color          : color of fractal
    maxiter        : when to break
                     color compute

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.conditionaltools.iif"><code>iif</code></a></h3>
<p><code>py
def iif(boolcond: bool, trueval: &lt;built-in function any&gt;, falseval: &lt;built-in function any&gt;) -&gt; &lt;built-in function any&gt;:</code></p>
<p>Returns trueval if
    boolcond is true
    else return falseval</p>
<pre><code>Args:
    boolcond: an expression that
              evaluates as either
              True or False
    trueval : value to return if
              boolcond evaluates
              to True
    falseval: value to return if
              boolcond evaluates
              to False

Returns:
    a value depending on boolcond
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.imagecomp"><code>imagecomp</code></a></h3>
<p><code>py
def imagecomp(inputfile1: str, inputfile2: str, diff_file: str, func: Callable):</code></p>
<p>Perform a bitwise comparison of two bitmap files
with the same x and y dimensions and bit depth
using a user defined bitwise comparator function</p>
<pre><code>Args:
    Inputfile1: path to bmp file
    Inputfile2: path to bmp file
    diff_file : New file to save
                comparison in
    func      : User provided
                bitwise function

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.imagediff"><code>imagediff</code></a></h3>
<p><code>py
def imagediff(inputfile1: str, inputfile2: str, diff_file: str):</code></p>
<p>Compares 2 files and saves diff to a bitmap file</p>
<pre><code>Args:
    inputfile1: Whole paths
    inputfile2 to existing files

    diff_file: New file
               to store diff

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.imgregionbyRGB2file"><code>imgregionbyRGB2file</code></a></h3>
<p><code>py
def imgregionbyRGB2file(ExistingBMPfile: str, NewBMPfile: str, edgeradius: int, edgecolor: int, rgb: list[int, int, int], similaritythreshold: float, showedgeonly: bool):</code></p>
<p>Gets an image region by rgb in a bitmap file</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    edgeradius     : radius of pen
                     for the edge
    edgecolor      : color of edge
    rgb            : (r: byte,
                      g: byte,
                      b: byte)
                     color to select
    similaritythreshold: how close
                         the color
                         is to rgb
                         before
                         selection
    showedgeonly: True-&gt; only edges
             False-&gt; edge and image

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.int2BGRarr"><code>int2BGRarr</code></a></h3>
<p><code>py
def int2BGRarr(i: int) -&gt; array.array:</code></p>
<p>Returns a bgr array from
    int i color input</p>
<pre><code>Args:
    i: color value

Returns:
    unsigned byte BGR array
</code></pre>
<h3><a href="#Python_BMP.inttools.int2buf"><code>int2buf</code></a></h3>
<p><code>py
def int2buf(cnt: int, value: int) -&gt; array.array:</code></p>
<p>Converts an integer value to an
    unsigned byte array</p>
<pre><code>Args:
    cnt   : uint length of int data
    value : value of uint data

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.colors.int2RGB"><code>int2RGB</code></a></h3>
<p><code>py
def int2RGB(i: int):</code></p>
<p>Break down int color i to its
    byte valued r, g and b
    components</p>
<pre><code>Args:
    i: int color value

Returns:
    r: byte, g: byte, b: byte
</code></pre>
<h3><a href="#Python_BMP.colors.int2RGBarr"><code>int2RGBarr</code></a></h3>
<p><code>py
def int2RGBarr(i: int) -&gt; array.array:</code></p>
<p>Returns a rgb array from
    int i color input</p>
<pre><code>Args:
    i: color value

Returns:
    unsigned byte RGB array
</code></pre>
<h3><a href="#Python_BMP.colors.int2RGBlist"><code>int2RGBlist</code></a></h3>
<p><code>py
def int2RGBlist(i: int) -&gt; list[int, int, int]:</code></p>
<p>Break down int color i to its
    byte valued r, g and b
    components in a list</p>
<pre><code>Args:
    i: int color value

Returns:
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.paramchecks.intcircleparam24bitonly"><code>intcircleparam24bitonly</code></a></h3>
<p><code>py
def intcircleparam24bitonly(func):</code></p>
<p>Decorator to test if 2nd, 3rd,
    4th parameters in a function
    that renders circle are ints
    and restrict the use of this
    function to only 24-bit or
    RGB bitmaps (1st parameter)</p>
<pre><code>Args:
    function(bmp:array,x,y,r....)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.paramchecks.intcircleparam"><code>intcircleparam</code></a></h3>
<p><code>py
def intcircleparam(func):</code></p>
<p>Decorator to test if the
    2nd, 3rd, 4th parameters
    in a function that renders
    circle are ints</p>
<pre><code>Args:
    function(bmp:array,x,y,r....)

Returns:
    caller function
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.intlinevec"><code>intlinevec</code></a></h3>
<p><code>py
def intlinevec(bmp: array.array, u: list, v: list, color: int):</code></p>
<p>Draw a line in a bitmap</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    u, v  : (x: int, y: int) points
            that defines the line
    color : color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.intplotvecxypoint"><code>intplotvecxypoint</code></a></h3>
<p><code>py
def intplotvecxypoint(bmp: array.array, v: list[int, int], c: int):</code></p>
<p>Sets the color of a pixel at (x, y)</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    v  : (x:int, y:int)
         pixel coordinates
    c  : unsigned int
         color value

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.intscalarmulvect"><code>intscalarmulvect</code></a></h3>
<p><code>py
def intscalarmulvect(vec: list[numbers.Number], scalarval: numbers.Number) -&gt; list[int]:</code></p>
<p>Scales a vector by multiplying a scalar value (float)
to all components of the vector or a list of numbers
then rounds off values in the list to a whole number</p>
<pre><code>Args:
    v        : the vector or
               a list of
               ints or floats
    scalarval: scalar value
               (float or int)

Returns:
    list of ints
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertbits2file"><code>invertbits2file</code></a></h3>
<p><code>py
def invertbits2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Inverts the bits in a bmp file</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.invertbitsinbuffer"><code>invertbitsinbuffer</code></a></h3>
<p><code>py
def invertbitsinbuffer(buf: array.array) -&gt; array.array:</code></p>
<p>Flips all the bits in an
    unsigned byte array</p>
<pre><code>Args:
    buf: unsigned byte array

Returns:
    bit flipped unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertbitsincircregion2file"><code>invertbitsincircregion2file</code></a></h3>
<p><code>py
def invertbitsincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Inverts bits in a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertbitsincircregion"><code>invertbitsincircregion</code></a></h3>
<p><code>py
def invertbitsincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Inverts the bits in a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x,y)
             and radius r
             of the region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertimagebits"><code>invertimagebits</code></a></h3>
<p><code>py
def invertimagebits(bmp: array.array):</code></p>
<p>Inverts the bits in a bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertregion2file"><code>invertregion2file</code></a></h3>
<p><code>py
def invertregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Inverts the bits in a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.invertregion"><code>invertregion</code></a></h3>
<p><code>py
def invertregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Inverts the bits in a
    rectangular region defined
    by (x1,y1) and (x2,y2)</p>
<pre><code>Args:
    bmp          :  unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.isdefaultpal"><code>isdefaultpal</code></a></h3>
<p><code>py
def isdefaultpal(bmp: array.array) -&gt; bool:</code></p>
<p>Checks if bitmap has a default RGB color palette</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    True if default
    False if not default
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.isinBMPrectbnd"><code>isinBMPrectbnd</code></a></h3>
<p><code>py
def isinBMPrectbnd(bmp: array.array, x: int, y: int) -&gt; bool:</code></p>
<p>Checks if (x,y) coordinates are within the BMP</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int value
          of location
          in x-axis and y-axis

Returns:
    True if within bounds
    False if out of bounds
</code></pre>
<h3><a href="#Python_BMP.mathlib.isinrange"><code>isinrange</code></a></h3>
<p><code>py
def isinrange(value: numbers.Number, highlimit: numbers.Number, lowlimit: numbers.Number) -&gt; bool:</code></p>
<p>Checks is value is within high and low limits</p>
<pre><code>Args:
    value    : numeric variable
               to check
    highlimit: upper limit of
               the variable
    lowlimit : lower limit of
               the variable

Returns:
    True if within bounds
</code></pre>
<h3><a href="#Python_BMP.primitives2D.isinrectbnd"><code>isinrectbnd</code></a></h3>
<p><code>py
def isinrectbnd(x: int, y: int, xmin: int, ymin: int, xmax: int, ymax: int) -&gt; bool:</code></p>
<p>Checks if the x and y values
lie within the rectangular area
defined by xmin, ymin and xmax, ymax</p>
<pre><code>Args:
    x, y: (x,y) coordinates to test
    xmin, ymin: min (x, y) bounds
    xmax, ymax: max (x, y) bounds

Returns:
    boolean value
    True  -&gt; (x, y) is in bounds
    False -&gt; (x, y) is out of bounds
</code></pre>
<h3><a href="#Python_BMP.colors.isvalidcolorbit"><code>isvalidcolorbit</code></a></h3>
<p><code>py
def isvalidcolorbit(bits: int) -&gt; bool:</code></p>
<p>Checks if bits is in the valid
    color bits list (1, 4, 8, 24)</p>
<pre><code>Args:
    bits: int value

Returns:
    True if bits in (1, 4, 8, 24)
    False if other values not in
          the list above
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterbeziercurve"><code>iterbeziercurve</code></a></h3>
<p><code>py
def iterbeziercurve(pntlist: list[list[int, int]]) -&gt; list[int, int]:</code></p>
<p>Yields a list of vertices for a bezier curve
based on 2D control points in pntlist</p>
<pre><code>Args:
    pntlist: 2D control points
             for the bezier curve
             as list[list[x: int,
                          y: int]]

Yields:
    vertices as list[x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterbspline"><code>iterbspline</code></a></h3>
<p><code>py
def iterbspline(pntlist: list[list[int, int]], isclosed: bool, curveback: bool) -&gt; list[int, int]:</code></p>
<p>Yields a list of vertices for a bspline curve
based on 2D control points in pntlist</p>
<pre><code>Args:
    pntlist: 2D control points
             for the bspline curve
             as list[list[x: int,
                          y: int]]

Yields:
    vertices as list[x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itercircle"><code>itercircle</code></a></h3>
<p><code>py
def itercircle(x: int, y: int, r: int) -&gt; list[int, int]:</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by radius r as it traces
a circle with origin set at (x, y)</p>
<pre><code>Args:
    x, y: int centerpoint
              coordinates
    r   : int radius

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itercircleinvolute"><code>itercircleinvolute</code></a></h3>
<p><code>py
def itercircleinvolute(x: int, y: int, a: float, delta: float, lim: float):</code></p>
<p>Yields (int, int) 2D vertices
along a path defined by the involute
of a circle with scaling factor a
and an origin set at (x, y)</p>
<pre><code>The involute of a circle is the path
traced out by a point on a straight
line that rolls around a circle.

It was studied by Huygens when he was
considering clocks without pendulums
that might be used on ships at sea.

Args:
    x, y : center of the curve
    a    : scaling factor
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    The vertices of the
    involute of a circle
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itercirclepart"><code>itercirclepart</code></a></h3>
<p><code>py
def itercirclepart(r: int) -&gt; list[int, int]:</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by radius r as it traces
one fourth of a circle with origin set
at (0, 0)</p>
<pre><code>Args:
    r: int radius

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itercirclepartlineedge"><code>itercirclepartlineedge</code></a></h3>
<p><code>py
def itercirclepartlineedge(r: int) -&gt; list[int, int]:</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by radius r as it traces
one fourth of a circle with origin set
at (0, 0) tuned for generating
filled circles with horizontal lines
 and other tasks involving circular areas</p>
<pre><code>Args:
    r: int radius

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itercirclepartvertlineedge"><code>itercirclepartvertlineedge</code></a></h3>
<p><code>py
def itercirclepartvertlineedge(r: int) -&gt; list[int, int]:</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by radius r as it traces
one fourth of a circle with origin set
at (0, 0) tuned for generating
filled circles with vertical lines
and other tasks involving circular areas</p>
<pre><code>Args:
    r: int radius

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.itercopyrect"><code>itercopyrect</code></a></h3>
<p><code>py
def itercopyrect(bmp: array.array, x1: int, y1: int, x2: int, y2: int) -&gt; array.array:</code></p>
<p>Scan a rectangular area and yield scan lines</p>
<pre><code>Args:
    bmp            : unsigned
                     byte array
                     with bmp format
    x1, y1, x2, y2 : defines the
                     rectangle

Yields:
    unsigned byte array
    scanlines of the area
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterdrawvec"><code>iterdrawvec</code></a></h3>
<p><code>py
def iterdrawvec(u: list, v: list, headsize: int):</code></p>
<p>Yields a vector (line segment with arrow head)</p>
<pre><code>Args:
    u       : (x: float, y: float)
              point 1 origin
    v       : (x: float, y: float)
              point 2 has arrow
    headsize: size of the arrow
              0 for default size

Yields:
    ((x1: int, y1: int), (x2: int, y2: int))
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterellipse"><code>iterellipse</code></a></h3>
<p><code>py
def iterellipse(x: int, y: int, b: int, a: int):</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by major and minor axes
b and a as it traces an ellipse with
origin set at (x, y)</p>
<pre><code>Args:
    b, a: major and minor axes

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterellipsepart"><code>iterellipsepart</code></a></h3>
<p><code>py
def iterellipsepart(b: int, a: int):</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by major and minor axes
b and a as it traces one fourth of an
ellipse with origin set at (0, 0)</p>
<pre><code>Args:
    b, a: major and minor axes

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterellipserot"><code>iterellipserot</code></a></h3>
<p><code>py
def iterellipserot(x: int, y: int, b: int, a: int, degrot: float):</code></p>
<p>Yields (int, int) 2D vertices along
a path defined by major and minor axes
b and a as it traces an ellipse with origin
set at (x, y) rotated by degrot degrees</p>
<pre><code>Args:
    b, a: major and minor axes
    degrot: rotation in degrees

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterepicycloid"><code>iterepicycloid</code></a></h3>
<p><code>py
def iterepicycloid(x: int, y: int, a: float, b: float, delta: float, lim: float):</code></p>
<p>Yields (int, int) 2D vertices
along a path defined by epicycloid
traced by a circleof radius b which
rolls round a circle of radius a
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of epicycloid
    a    : radius of fixed circle
    b    : radius of rolling circle
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    The vertices of an
    epicycloid
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterflower"><code>iterflower</code></a></h3>
<p><code>py
def iterflower(cx: int, cy: int, r: int, petals: int, angrot: float):</code></p>
<p>Yields 2D points for a flower</p>
<pre><code>Args:
    cx, cy, r : center (cx,cy)
                and radius r
    petals    : number of petals
    angrot    : angle of rotation

Yields:
    (x: int, y: int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.itergetcolorfromrectregion"><code>itergetcolorfromrectregion</code></a></h3>
<p><code>py
def itergetcolorfromrectregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Yields color info of
    a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Yields:
    ((x: int, y: int), color: int)
    for all points in area
</code></pre>
<h3><a href="#Python_BMP.primitives2D.itergetneighbors"><code>itergetneighbors</code></a></h3>
<p><code>py
def itergetneighbors(v: list[int, int], mx: int, my: int, includecenter: bool) -&gt; list[int, int]:</code></p>
<p>Yields the neighboring pixels of point v</p>
<pre><code>Args:
    v : (x: int, y: int) point
    mx: maximum x
    my: maximum y
    includecenter: do we yield
                   point v too

Yields:
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterhypotrochoid"><code>iterhypotrochoid</code></a></h3>
<p><code>py
def iterhypotrochoid(x: int, y: int, a: float, b: float, c: float, delta: float, lim: float):</code></p>
<p>Yields (int, int) 2D vertices
along a path defined by a hypotrochoid
traced by a point from with distance c
from the center of circle of radius b
which rolls round a circle of radius a
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of epicycloid
    a    : radius of fixed circle
    b    : radius of rolling circle
    c    : distance of pen from the
           center of circle with
           radius b
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    The vertices of an
    epicycloid
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.fractals.iterIFS"><code>iterIFS</code></a></h3>
<p><code>py
def iterIFS(IFStransparam: tuple, x1: int, y1: int, x2: int, y2: int, xscale: int, yscale: int, xoffset: int, yoffset: int, maxiter: int):</code></p>
<p>Yield 2D points for an Interated Function System Fractal</p>
<pre><code>Args:
    IFStransparam   : see line 19
    x1, y1, x2, y2  : rectangular
                      region
                      to draw in
    xscale, yscale  : scaling factors
    xoffset, yoffset: used to move
                      the fractal
    maxiter         : when to break
                      color compute

Yields:
    (x: int, y: int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.iterimagecolor"><code>iterimagecolor</code></a></h3>
<p><code>py
def iterimagecolor(bmp: array.array, waitmsg: str, rowprocind: str, finishmsg: str):</code></p>
<p>Yields color information for entire bitmap</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    waitmsg   : what to display
                in the terminal
                when process starts
    rowprocind: string to print in
                the terminal as a
                row is processed as
                a process indicator
    finishmsg : what to display
                in the terminal
                when process ends

Yields:
    ((x: int, y: int), color: int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.iterimagedgevert"><code>iterimagedgevert</code></a></h3>
<p><code>py
def iterimagedgevert(bmp: array.array, similaritythreshold: float):</code></p>
<p>Find edges in an image</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with
                         bmp format
    similaritythreshold: how close
                         to the color
                         before we
                         yield it

Yields:
    (x: int, y: int)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.iterimageregionvertbyRGB"><code>iterimageregionvertbyRGB</code></a></h3>
<p><code>py
def iterimageregionvertbyRGB(bmp: array.array, rgb: list[int, int, int], similaritythreshold: int):</code></p>
<p>RGB Color selection by color similarity</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with bmp
                         format
    rgb                : (r: byte,
                          g: byte,
                          b: byte)
    similaritythreshold: how close
                         to the color
                         before we
                         yield it

Yields:
    ((x: int, y: int), (r: byte, g: byte, b: byte))
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.iterimageRGB"><code>iterimageRGB</code></a></h3>
<p><code>py
def iterimageRGB(bmp: array.array, waitmsg: str, rowprocind: str, finishmsg: str):</code></p>
<p>Yields (r, g, b) information for the entire bitmap</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    waitmsg   : what to display
                in terminal at
                process start
    rowprocind: char to display as
                a row is processed
    finishmsg : what to display
                in terminal at
                process end

Yields:
    ((x: int, y: int), (r: byte, g: byte, b: byte))
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterline"><code>iterline</code></a></h3>
<p><code>py
def iterline(p1: list[int, int], p2: list[int, int]) -&gt; list[int, int]:</code></p>
<p>Yields (int, int) 2D vertices
along a line segment defined
by endpoints p1 and p2</p>
<pre><code>Args:
    p1, p2: line endpoints
            both [x:int, y:int]

Yields:
    [x:int, y:int]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterlissajouscurve"><code>iterlissajouscurve</code></a></h3>
<p><code>py
def iterlissajouscurve(x: int, y: int, a: float, b: float, c: float, d: float, e: float, delta: float, lim: float):</code></p>
<p>Yields (int, int) 2D vertices
along a path defined by lissajous
curve axis scaling factors a and b
and frequency scaling factors
parameters c and d and
radian phase shift angle e
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of the curve
    a, b : axis scaling factors
    c, d : frequency scaling factors
    e    : phase shift in radians
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    Vertices of a lissajous curve
    [x: int, y: int]
</code></pre>
<h3><a href="#Python_BMP.fractals.itermandelbrot"><code>itermandelbrot</code></a></h3>
<p><code>py
def itermandelbrot(x1: int, y1: int, x2: int, y2: int, mandelparam: list[float, float, float, float], maxiter: int):</code></p>
<p>Yields a Mandelbrot set</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: rectangular area
                    to draw in
    mandelparam   : see fractals.py
    rgbfactors    : [r, b, g] values
                    range from
                    0.0 to 1.0
    maxiter       : when to break
                    color compute

Yields:
    (x:int, y: int, c: int)
</code></pre>
<h3><a href="#Python_BMP.primitives2D.iterparallelogram"><code>iterparallelogram</code></a></h3>
<p><code>py
def iterparallelogram(p1: list[int, int], p2: list[int, int], p3: list[int, int]) -&gt; list[int, int]:</code></p>
<h3><a href="#Python_BMP.primitives2D.iterspirograph"><code>iterspirograph</code></a></h3>
<p><code>py
def iterspirograph(x: int, y: int, r: int, l: float, k: float, delta: float, lim: float):</code></p>
<p>Yields (int, int) 2D vertices
along a path defined by spirograph
scaling factor r and dimensionless
parameters l and k with an origin
set at (x, y)</p>
<pre><code>Args:
    x, y : center of the spirograph
    r    : spirograph scaling factor
    l, k : spirograph shape parameters
    delta: angle increment in radians
    lim  : angle limit in radians

Yields:
    The vertices of an
    spirograph
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.line"><code>line</code></a></h3>
<p><code>py
def line(bmp: array.array, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Draw a Line in a bitmap</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    x1, y1: endpoint 1
    x2, y2: endpoint 2
    color : color of the line

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.linevec"><code>linevec</code></a></h3>
<p><code>py
def linevec(bmp: array.array, u: list, v: list, color: int):</code></p>
<p>Draw a line in a bitmap</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    u, v : (x:float,y:float)
           the endpoints
           of the line
    color: the color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.lissajouscurvevert"><code>lissajouscurvevert</code></a></h3>
<p><code>py
def lissajouscurvevert(x: int, y: int, a: float, b: float, c: float, d: float, e: float, delta: float, lim: float):</code></p>
<p>Returns (int, int) 2D vertices
along a path defined by a lissajous curve
axis scaling factors a and b and
frequency scaling factors parameters
c and d and radian phase shift angle e
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of the curve
    a, b : axis scaling factors
    c, d : frequency scaling factors
    e    : phase shift in radians
    delta: angle increment in radians
    lim  : angle limit in radians

Returns:
    Vertices of a lissajous curve
    in a list [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.listinBMPrecbnd"><code>listinBMPrecbnd</code></a></h3>
<p><code>py
def listinBMPrecbnd(bmp: array.array, xylist: list) -&gt; bool:</code></p>
<p>Checks if a list of (x, y) coordinates are within the BMP</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    xylist: list of (x, y)
            coordinates
            to be checked

Returns:
    True if within bounds
    False if out of bounds
</code></pre>
<h3><a href="#Python_BMP.primitives2D.listinrecbnd"><code>listinrecbnd</code></a></h3>
<p><code>py
def listinrecbnd(xylist: list[list[numbers.Number, numbers.Number]], xmin: int, ymin: int, xmax: int, ymax: int) -&gt; bool:</code></p>
<p>Checks if all the values in a
list of x and y value pairs
lie within the rectangular area
defined by xmin, ymin and xmax, ymax</p>
<pre><code>Args:
    x, y: list[list(x,y)] list of
          x, y pairs to test
    xmin, ymin: min (x, y) bounds
    xmax, ymax: max (x, y) bounds


Returns:
    boolean value
    True  -&gt; All (x, y)
             is in bounds
    False -&gt; Not all (x, y)
             is in bounds
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.loadBMP"><code>loadBMP</code></a></h3>
<p><code>py
def loadBMP(filename: str) -&gt; array.array:</code></p>
<p>Load bitmap to a byte array
   (uncompressed bitmap only)</p>
<pre><code>Args:
    filename: full path to
              the file to be loaded

Returns:
    byte array with bmp file contents
</code></pre>
<h3><a href="#Python_BMP.mathlib.LSMslope"><code>LSMslope</code></a></h3>
<p><code>py
def LSMslope(XYdata: list) -&gt; float:</code></p>
<p>Slope of a line obtained by Least Squares Method</p>
<pre><code>Args:
    XYdata: list of vectors
    first two values in the
    list must be [[x, y, ..,], ...]

Returns:
    float slope of line
</code></pre>
<h3><a href="#Python_BMP.mathlib.LSMYint"><code>LSMYint</code></a></h3>
<p><code>py
def LSMYint(XYdata: list) -&gt; float:</code></p>
<p>Returns the y-intercept of a line obtained
by Least Squares Method</p>
<pre><code>Args:
    XYdata: list of vectors
    first two values in the
    list must be [[x, y, ..,], ...]

Returns:
    float y-intercept of line
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.magnifyNtimescircregion2file"><code>magnifyNtimescircregion2file</code></a></h3>
<p><code>py
def magnifyNtimescircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, intmagfactor: int):</code></p>
<p>Magnify a circular region by an integer factor n times</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
    intmagfactor   : int magnification
                     factor

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.magnifyNtimescircregion"><code>magnifyNtimescircregion</code></a></h3>
<p><code>py
def magnifyNtimescircregion(bmp: array.array, x: int, y: int, r: int, n: int):</code></p>
<p>Magnify a circular region in a bitmap file by int n</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x,y)
             and radius r
    n      : int magnification
             factor

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.colors.makeBGRbuf"><code>makeBGRbuf</code></a></h3>
<p><code>py
def makeBGRbuf(bbuf: array.array, gbuf: array.array, rbuf: array.array) -&gt; array.array:</code></p>
<p>Assemble a BGR buffer from
    blue, green and red buffers</p>
<pre><code>Args:
    bbuf: unsigned byte array
          for blue data
    gbuf: unsigned byte array
          for green data
    rbuf: unsigned byte array
          for red data

Returns:
    unsigned byte array
    holding BGR data
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.makenewpalfromcolorhist"><code>makenewpalfromcolorhist</code></a></h3>
<p><code>py
def makenewpalfromcolorhist(chist: list, colors: int, similaritythreshold: float) -&gt; list:</code></p>
<p>Creates a new palatte based on a color histogram</p>
<pre><code>Args:
    chist              : list sorted in
                         descending order
                         of color
                         frequencies
    colors             : maximum colors
                         of new palette
    similaritythreshold: controls how
                         close palette
                         entries can be

Returns:
    unsigned byte array with bmp format
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mandelbrot"><code>mandelbrot</code></a></h3>
<p><code>py
def mandelbrot(bmp: array.array, x1: int, y1: int, x2: int, y2: int, mandelparam: list[float, float, float, float], RGBfactors: list[float, float, float], maxiter: int):</code></p>
<p>Draw a Mandelbrot set</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: rectangular area
                    to draw in
    mandelparam   : see fractals.py
    rgbfactors    : [r, b, g] values
                    range from
                    0.0 to 1.0
    maxiter       : when to break
                    color compute

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.fractals.mandelparamdict"><code>mandelparamdict</code></a></h3>
<p><code>py
def mandelparamdict() -&gt; dict:</code></p>
<h3><a href="#Python_BMP.colors.matchRGBtopal"><code>matchRGBtopal</code></a></h3>
<p><code>py
def matchRGBtopal(RGB: list, pal: list) -&gt; int:</code></p>
<p>Color matching from a 24-bit
    palette to any 1, 4 or 8-bit
    palette using Euclidean
    distance minimization
    in an rgb colorspace for
    the closest color match</p>
<pre><code>Args:
    RGB: color byte values
         [r: byte,
          g: byte,
          b: byte]
    pal: the bmp palette to match

Returns:
    int color val (4-bit)
</code></pre>
<h3><a href="#Python_BMP.mathlib.mirror"><code>mirror</code></a></h3>
<p><code>py
def mirror(pt: float, delta: float):</code></p>
<p>Mirrors a value in a numberline</p>
<pre><code>Args:
    pt   : real value in numberline
    delta: value to mirror

Returns:
    pt - delta, pt + delta
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottom2file"><code>mirrorbottom2file</code></a></h3>
<p><code>py
def mirrorbottom2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the bottom half of a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to an existing
                     file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottom"><code>mirrorbottom</code></a></h3>
<p><code>py
def mirrorbottom(bmp: array.array):</code></p>
<p>Mirrors the bottom-half of a bmp</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomincircregion2file"><code>mirrorbottomincircregion2file</code></a></h3>
<p><code>py
def mirrorbottomincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-half of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomincircregion"><code>mirrorbottomincircregion</code></a></h3>
<p><code>py
def mirrorbottomincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-half of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottominregion2file"><code>mirrorbottominregion2file</code></a></h3>
<p><code>py
def mirrorbottominregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the bottom-half region in a rectangular area in a bmp</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottominregion"><code>mirrorbottominregion</code></a></h3>
<p><code>py
def mirrorbottominregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirror the bottom-half
    of a rectangular region</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleft2file"><code>mirrorbottomleft2file</code></a></h3>
<p><code>py
def mirrorbottomleft2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the bottom-left of a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleft"><code>mirrorbottomleft</code></a></h3>
<p><code>py
def mirrorbottomleft(bmp: array.array):</code></p>
<p>Mirrors the bottom-left part
    of an in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleftincircregion2file"><code>mirrorbottomleftincircregion2file</code></a></h3>
<p><code>py
def mirrorbottomleftincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-left of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleftincircregion"><code>mirrorbottomleftincircregion</code></a></h3>
<p><code>py
def mirrorbottomleftincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-left of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x,y) and
             radius r of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleftinregion2file"><code>mirrorbottomleftinregion2file</code></a></h3>
<p><code>py
def mirrorbottomleftinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the bottom-left region in a rectangular area in a bmp</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomleftinregion"><code>mirrorbottomleftinregion</code></a></h3>
<p><code>py
def mirrorbottomleftinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the bottom-left of a
    rectangular region defined
    by (x1, y1) and (x2, y2)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomright2file"><code>mirrorbottomright2file</code></a></h3>
<p><code>py
def mirrorbottomright2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the bottom-right of a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomright"><code>mirrorbottomright</code></a></h3>
<p><code>py
def mirrorbottomright(bmp: array.array):</code></p>
<p>Mirrors the bottom right part
    of an in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomrightincircregion2file"><code>mirrorbottomrightincircregion2file</code></a></h3>
<p><code>py
def mirrorbottomrightincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-right of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomrightincircregion"><code>mirrorbottomrightincircregion</code></a></h3>
<p><code>py
def mirrorbottomrightincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the bottom-right of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x,y) and
             radius r of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomrightinregion2file"><code>mirrorbottomrightinregion2file</code></a></h3>
<p><code>py
def mirrorbottomrightinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the bottom-right region in a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2  :the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorbottomrightinregion"><code>mirrorbottomrightinregion</code></a></h3>
<p><code>py
def mirrorbottomrightinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the bottom-right of a
    rectangular region defined by
    (x1, y1) and (x2, y2)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleft2file"><code>mirrorleft2file</code></a></h3>
<p><code>py
def mirrorleft2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the left-half of a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleft"><code>mirrorleft</code></a></h3>
<p><code>py
def mirrorleft(bmp: array.array):</code></p>
<p>Mirrors the left-half of an
    in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleftincircregion2file"><code>mirrorleftincircregion2file</code></a></h3>
<p><code>py
def mirrorleftincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the left-half of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleftincircregion"><code>mirrorleftincircregion</code></a></h3>
<p><code>py
def mirrorleftincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirrors the top-left of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y) and
             radius r of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleftinregion2file"><code>mirrorleftinregion2file</code></a></h3>
<p><code>py
def mirrorleftinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the left-half region in a rectangular area in a bmp</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorleftinregion"><code>mirrorleftinregion</code></a></h3>
<p><code>py
def mirrorleftinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the left-half
    of a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorright2file"><code>mirrorright2file</code></a></h3>
<p><code>py
def mirrorright2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the right half of a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorright"><code>mirrorright</code></a></h3>
<p><code>py
def mirrorright(bmp: array.array):</code></p>
<p>Mirrors the right-half of an
    in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorrightincircregion2file"><code>mirrorrightincircregion2file</code></a></h3>
<p><code>py
def mirrorrightincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the right-half of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorrightincircregion"><code>mirrorrightincircregion</code></a></h3>
<p><code>py
def mirrorrightincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirrors the right-half of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of a region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorrightinregion2file"><code>mirrorrightinregion2file</code></a></h3>
<p><code>py
def mirrorrightinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the right-half region in a rectangular area in a bmp</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrorrightinregion"><code>mirrorrightinregion</code></a></h3>
<p><code>py
def mirrorrightinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the right-half of
    a rectangular area in a bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortop2file"><code>mirrortop2file</code></a></h3>
<p><code>py
def mirrortop2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the top-half of a bitmap</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortop"><code>mirrortop</code></a></h3>
<p><code>py
def mirrortop(bmp: array.array):</code></p>
<p>Mirrors the top-half of a bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopincircregion2file"><code>mirrortopincircregion2file</code></a></h3>
<p><code>py
def mirrortopincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the top-half of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopincircregion"><code>mirrortopincircregion</code></a></h3>
<p><code>py
def mirrortopincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the top-half of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r of area

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopinregion2file"><code>mirrortopinregion2file</code></a></h3>
<p><code>py
def mirrortopinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the top-half region in a rectangular area in a bmp</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopinregion"><code>mirrortopinregion</code></a></h3>
<p><code>py
def mirrortopinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirror the top-half of
    a rectangular region</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleft2file"><code>mirrortopleft2file</code></a></h3>
<p><code>py
def mirrortopleft2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the top-left of a bitmap</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleft"><code>mirrortopleft</code></a></h3>
<p><code>py
def mirrortopleft(bmp):</code></p>
<p>Mirrors the top-left part
    of an in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleftincircregion2file"><code>mirrortopleftincircregion2file</code></a></h3>
<p><code>py
def mirrortopleftincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the top-left of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleftincircregion"><code>mirrortopleftincircregion</code></a></h3>
<p><code>py
def mirrortopleftincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the top-left of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleftinregion2file"><code>mirrortopleftinregion2file</code></a></h3>
<p><code>py
def mirrortopleftinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the top-left region in a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopleftinregion"><code>mirrortopleftinregion</code></a></h3>
<p><code>py
def mirrortopleftinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the top-left of a
    rectangular region defined by
    (x1, y1) and (x2, y2)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopright2file"><code>mirrortopright2file</code></a></h3>
<p><code>py
def mirrortopright2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Mirrors the top-right of a
    bitmap file</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to existing
                     file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortopright"><code>mirrortopright</code></a></h3>
<p><code>py
def mirrortopright(bmp: array.array):</code></p>
<p>Mirrors the top-right part
    of an in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortoprightincircregion2file"><code>mirrortoprightincircregion2file</code></a></h3>
<p><code>py
def mirrortoprightincircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Mirror the top-right of a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortoprightincircregion"><code>mirrortoprightincircregion</code></a></h3>
<p><code>py
def mirrortoprightincircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Mirror the top-right of a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y) and
             radius r of region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortoprightinregion2file"><code>mirrortoprightinregion2file</code></a></h3>
<p><code>py
def mirrortoprightinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the top-right region in a rectangular area in a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : the rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.mirrortoprightinregion"><code>mirrortoprightinregion</code></a></h3>
<p><code>py
def mirrortoprightinregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Mirrors the top-right of a
    rectangular region defined by
    (x1, y1) and (x2, y2)</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monochrome2file"><code>monochrome2file</code></a></h3>
<p><code>py
def monochrome2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Applies a monochrome filter to a BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.monochrome"><code>monochrome</code></a></h3>
<p><code>py
def monochrome(rgb: list[int, int, int]) -&gt; list[int, int, int]:</code></p>
<p>Returns a monochrome color
    based on a 24-bit RGB value</p>
<pre><code>Args:
    rgb: color values
        [r: byte, g: byte, b: byte]

Returns:
    a gray color (r = g = b)
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monochromecircregion2file"><code>monochromecircregion2file</code></a></h3>
<p><code>py
def monochromecircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Monochrome filter to a circular region</p>
<pre><code>Args:
    ExistingBMPfile: Whole path
                     to an existing
                     file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.monochromefiltertoBGRbuf"><code>monochromefiltertoBGRbuf</code></a></h3>
<p><code>py
def monochromefiltertoBGRbuf(buf: array.array) -&gt; array.array:</code></p>
<p>Apply a monochrome filter to a
    BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding BGR data

    rgbfactors: color filter as
                  [r: float,
                   g: float,
                   b: float]

Returns:
    unsigned byte array
    holding mono BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.monochromepal"><code>monochromepal</code></a></h3>
<p><code>py
def monochromepal(bits: int, rgbfactors: list[float, float, float]) -&gt; list[list[int, int, int]]:</code></p>
<p>Returns a monochrome palette
    based on bit depth bits and
    rgbfactors</p>
<pre><code>Args:
    bits      : bit depth
                (1, 4, 8)
    rgbfactors: color values
                0.0 to 1.0
                [r: float,
                 g: float,
                 b: float]

Returns:
  a palette as
  list[list[r: int, g: int, b int]]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monocircle"><code>monocircle</code></a></h3>
<p><code>py
def monocircle(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Monochrome filter to a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monofilterinregion2file"><code>monofilterinregion2file</code></a></h3>
<p><code>py
def monofilterinregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Monochrome filter to rectangular area in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monofilterto24bitimage"><code>monofilterto24bitimage</code></a></h3>
<p><code>py
def monofilterto24bitimage(bmp: array.array):</code></p>
<p>Applies a mono filter
    to a 24 bit in-memory bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.monofilterto24bitregion"><code>monofilterto24bitregion</code></a></h3>
<p><code>py
def monofilterto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Applies a monochrome filter
    to a rectangular area
    defined by (x1, y1) and
    (x2, y2) in a 24 bit bitmap</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangle

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.newBMP"><code>newBMP</code></a></h3>
<p><code>py
def newBMP(x: int, y: int, colorbits: int) -&gt; array.array:</code></p>
<p>Creates a new in-memory bitmap</p>
<pre><code>Args:
    x, y     : unsigned int values
               of x and y dims
    colorbits: bit depth
               (1, 4, 8, 24) bits

Returns:
    unsigned byte array with bitmap layout
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.numbervert"><code>numbervert</code></a></h3>
<p><code>py
def numbervert(bmp: array.array, vlist: list[list[int, int]], xadj: int, yadj: int, scale: int, valstart: numbers.Number, valstep: numbers.Number, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list, suppresszero: bool, suppresslastnum: bool, rightjustify: bool):</code></p>
<h3><a href="#Python_BMP.solids3D.octahedravert"><code>octahedravert</code></a></h3>
<p><code>py
def octahedravert(x: float) -&gt; list[list[float, float, float]]:</code></p>
<p>Returns a list of vertices
    for an octrahedron</p>
<pre><code>Args:
    x: length of a side

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outline2file"><code>outline2file</code></a></h3>
<p><code>py
def outline2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Applies an outline filter</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outline"><code>outline</code></a></h3>
<p><code>py
def outline(bmp: array.array):</code></p>
<p>Applies an Outline Filter</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outlinecircregion2file"><code>outlinecircregion2file</code></a></h3>
<p><code>py
def outlinecircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int):</code></p>
<p>Outlines area in a circular region</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outlinecircregion"><code>outlinecircregion</code></a></h3>
<p><code>py
def outlinecircregion(bmp: array.array, x: int, y: int, r: int):</code></p>
<p>Outlines a circular area</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of the region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outlineregion2file"><code>outlineregion2file</code></a></h3>
<p><code>py
def outlineregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Outline filter to rectangular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x1, y1, x2, y2 : defines the
                     rectangular
                     region

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.outlineregion"><code>outlineregion</code></a></h3>
<p><code>py
def outlineregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Outines a rectangular region in a BMP</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines
                    the rectangular
                    region

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pastecirularbuf"><code>pastecirularbuf</code></a></h3>
<p><code>py
def pastecirularbuf(bmp: array.array, x: int, y: int, circbuf: list):</code></p>
<p>Paste a circular buffer with a
given radius to a centerpoint at (x, y)</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y   : center of circular
             region
    circbuf: list generated by
             copycircregion2buf

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pasterect"><code>pasterect</code></a></h3>
<p><code>py
def pasterect(bmp: array.array, buf: array.array, x1: int, y1: int):</code></p>
<p>Paste a rectangular area from a buffer to a bmp</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    buf   : rectangular
            image buffer
    x1, y1: point to paste
            the buffer

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.solids3D.perspective"><code>perspective</code></a></h3>
<p><code>py
def perspective(vlist: list[list[numbers.Number, numbers.Number, numbers.Number]], rotvec: list[list[float, float], list[float, float], list[float, float]], dispvec: list[numbers.Number, numbers.Number, numbers.Number], d: float) -&gt; tuple:</code></p>
<p>Projects 3D points to 2D and
    apply rotation and translation
    vectors</p>
<pre><code>Args:
    vlist  : list of 3D vertices
    rotvec : 3D rotation vector
    dispvec: 3D translation vector
    d      : Distance of observer
             from the screen

Returns:
    tuple (list, list)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.piechart"><code>piechart</code></a></h3>
<p><code>py
def piechart(bmp: array.array, x: int, y: int, r: int, dataandcolorlist: list):</code></p>
<p>Draw a piechart</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y, r         : center (x, y)
                      and radius r
    dataandcolorlist: stuff to plot
                      + color

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pixelizenxn"><code>pixelizenxn</code></a></h3>
<p><code>py
def pixelizenxn(bmp: array.array, n: int) -&gt; array.array:</code></p>
<p>Pixelize a whole image with n by n areas
in which colors are averaged</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    n  : size of pixel blur

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pixelizenxncircregion2file"><code>pixelizenxncircregion2file</code></a></h3>
<p><code>py
def pixelizenxncircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, intpixsize: int):</code></p>
<p>Apply a Pixel Blur in a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
    intpixsize     : n by n
                     pixel blur size

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pixelizenxncircregion"><code>pixelizenxncircregion</code></a></h3>
<p><code>py
def pixelizenxncircregion(bmp: array.array, x: int, y: int, r: int, n: int):</code></p>
<p>Pixelize a circular region in a BMP by n</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
    n      : integer pixellation
             dimension n by n

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.pixelizenxntofile"><code>pixelizenxntofile</code></a></h3>
<p><code>py
def pixelizenxntofile(ExistingBMPfile: str, NewBMPfile: str, n: int):</code></p>
<p>Pixellate a bitmap file with n by n pixel areas</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot3d"><code>plot3d</code></a></h3>
<p><code>py
def plot3d(bmp: array.array, sides: list[list, list], issolid: bool, RGBfactors: list[float, float], showoutline: bool, outlinecolor: int):</code></p>
<p>The 3D rendering function</p>
<pre><code>Args:
    bmp         : unsigned
                  byte array
                  with bmp format
    sides       : list of polygons
                  and normals
    isolid      : toggles solid render
    RGBfactors  : [r,g,b] r, g, b
                  range in value
                  from 0.0 to 1.0
    showoutine  : toggles the
                  polygon outline
    outlinecolor: color of the
                  polygon outline

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot3Dsolid"><code>plot3Dsolid</code></a></h3>
<p><code>py
def plot3Dsolid(bmp: array.array, vertandsides: list[list, list], issolid: bool, RGBfactors: list[float, float, float], showoutline: bool, outlinecolor: int, rotvect: list[float, float, float], transvect3D: list[float, float, float], d: int, transvect: list[int, int]):</code></p>
<p>3D solid rendering function</p>
<pre><code>Args:
    bmp         : unsigned
                  byte array
                  with bmp format
    sides       : list of polygons
                  and normals
    isolid      : toggles the
                  solid render
    RGBfactors  : [r,g,b] r, g, b
                  range in value
                  from 0.0 to 1.0
    showoutine  : toggles the
                  polygon outline
    outlinecolor: color of the
                  polygon outline
    rotvect     : rotation vector
    transvect3D : 3D translation
                  vector
    d           : distance of the
                  observer from
                  the screen
    transvect   : 2D translation
                  vector for
                  screen position

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpattern"><code>plot8bitpattern</code></a></h3>
<p><code>py
def plot8bitpattern(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternasdots"><code>plot8bitpatternasdots</code></a></h3>
<p><code>py
def plot8bitpatternasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern as circles</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the
                pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.textgraphics.plot8bitpatternastext"><code>plot8bitpatternastext</code></a></h3>
<p><code>py
def plot8bitpatternastext(bitpattern: list[int], onechar: str, zerochar: str):</code></p>
<p>Outputs the bits of a list
    of bytes to console</p>
<pre><code>Args:
    bitpattern: list of bytes
    onechar   : char to display
                if bit is 1
    zeropchar : char to display
                if bit is 0

Returns:
    console output
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternsideway"><code>plot8bitpatternsideway</code></a></h3>
<p><code>py
def plot8bitpatternsideway(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern sideways</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternsidewaywithdots"><code>plot8bitpatternsidewaywithdots</code></a></h3>
<p><code>py
def plot8bitpatternsidewaywithdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern sideways with dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternsidewaywithfn"><code>plot8bitpatternsidewaywithfn</code></a></h3>
<p><code>py
def plot8bitpatternsidewaywithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Draws a 8-bit pattern sideways with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternupsidedown"><code>plot8bitpatternupsidedown</code></a></h3>
<p><code>py
def plot8bitpatternupsidedown(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern upsidedown</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the
                pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternupsidedownasdots"><code>plot8bitpatternupsidedownasdots</code></a></h3>
<p><code>py
def plot8bitpatternupsidedownasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern upsidedown with dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternupsidedownwithfn"><code>plot8bitpatternupsidedownwithfn</code></a></h3>
<p><code>py
def plot8bitpatternupsidedownwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Draws a 8-bit pattern upsidedown with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern
    fn        : function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plot8bitpatternwithfn"><code>plot8bitpatternwithfn</code></a></h3>
<p><code>py
def plot8bitpatternwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>8-bit pattern with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the
                pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.textgraphics.plotbitsastext"><code>plotbitsastext</code></a></h3>
<p><code>py
def plotbitsastext(bits: int):</code></p>
<p>Outputs the bits of byte to
    console</p>
<pre><code>Args:
    bits: byte value

Returns:
    space for 0
    *     for 1
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotbmpastext"><code>plotbmpastext</code></a></h3>
<p><code>py
def plotbmpastext(bmp: array.array):</code></p>
<p>Plot a bitmap as text
(cannot output 24-bit bmp)</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format

Returns:
    console text output
    for debug and ascii art
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotcircinsqr"><code>plotcircinsqr</code></a></h3>
<p><code>py
def plotcircinsqr(bmp, x, y, d, color):</code></p>
<p>Draws a circle in an
    invisible square with side
    equal to the circle's diameter
    and positioned by (x, y)
    at  the upper left
    of the bounding square</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    d         : diameter of the
                circle
 Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotfilledflower"><code>plotfilledflower</code></a></h3>
<p><code>py
def plotfilledflower(bmp: array.array, cx: int, cy: int, r: int, petals: float, angrot: float, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Draw a filled flower</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    cx, cy, r : center (cx, cy)
                and radius r
    petals    : number of petals
    angrot    : angle of rotation
    lumrange  : (byte:byte) range
                of brightness
    rgbfactors: [r, g, b] values
                of r, g and b
                range from
                0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotflower"><code>plotflower</code></a></h3>
<p><code>py
def plotflower(bmp: array.array, cx: int, cy: int, r: int, petals: float, angrot: float, lumrange: list[int, int], RGBfactors: list[float, float, float]):</code></p>
<p>Draw a flower</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    cx, cy, r : center (cx,cy)
                and radius r
    petals    : number of petals
    angrot    : angle of rotation
    lumrange  : (byte:byte) range
                of brightness for
                the gradient
    rgbfactors: [r, g, b] values
                all range from
                0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotimgedges"><code>plotimgedges</code></a></h3>
<p><code>py
def plotimgedges(bmp: array.array, similaritythreshold: int, edgeradius: int, edgecolor: int):</code></p>
<p>Draw edges</p>
<pre><code>Args:
    bmp                : unsigned
                         byte array
                         with bmp
                         format
    similaritythreshold: controls
                         the edge
                         detection
                         sensitivity
    edgeradius         : radius and
    edgecolor            color of
                         the pen
                         used to
                         draw the
                         edges

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpattern"><code>plotitalic8bitpattern</code></a></h3>
<p><code>py
def plotitalic8bitpattern(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit italic pattern</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the
                pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit
    color     : color of pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternasdots"><code>plotitalic8bitpatternasdots</code></a></h3>
<p><code>py
def plotitalic8bitpatternasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit italic pattern as dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternsideway"><code>plotitalic8bitpatternsideway</code></a></h3>
<p><code>py
def plotitalic8bitpatternsideway(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws an italic 8-bit pattern sideways</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternsidewayasdots"><code>plotitalic8bitpatternsidewayasdots</code></a></h3>
<p><code>py
def plotitalic8bitpatternsidewayasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws an italic 8-bit pattern sideways as dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternsidewaywithfn"><code>plotitalic8bitpatternsidewaywithfn</code></a></h3>
<p><code>py
def plotitalic8bitpatternsidewaywithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Draws an Italic 8-bit pattern sideways with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternupdsidedownasdots"><code>plotitalic8bitpatternupdsidedownasdots</code></a></h3>
<p><code>py
def plotitalic8bitpatternupdsidedownasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit italic pattern upsidedown as dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternupsidedownwithfn"><code>plotitalic8bitpatternupsidedownwithfn</code></a></h3>
<p><code>py
def plotitalic8bitpatternupsidedownwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Italic 8-bit pattern upsidedown with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to
                draw the pattern
    bitpattern: list of bytes that
                makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern
    fn        : function

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalic8bitpatternwithfn"><code>plotitalic8bitpatternwithfn</code></a></h3>
<p><code>py
def plotitalic8bitpatternwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Italic 8-bit pattern with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the
                pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstring"><code>plotitalicstring</code></a></h3>
<p><code>py
def plotitalicstring(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string as Italic</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstringasdots"><code>plotitalicstringasdots</code></a></h3>
<p><code>py
def plotitalicstringasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string as Italic dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstringsideway"><code>plotitalicstringsideway</code></a></h3>
<p><code>py
def plotitalicstringsideway(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws an Italic String Sideways</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
                      can be an int
                          or a
                      list of ints
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstringsidewayasdots"><code>plotitalicstringsidewayasdots</code></a></h3>
<p><code>py
def plotitalicstringsidewayasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws an italic string sideways as dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstringvertical"><code>plotitalicstringvertical</code></a></h3>
<p><code>py
def plotitalicstringvertical(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws an italic string vertically with dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotitalicstringverticalasdots"><code>plotitalicstringverticalasdots</code></a></h3>
<p><code>py
def plotitalicstringverticalasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws an italic string vertically with dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotlines"><code>plotlines</code></a></h3>
<p><code>py
def plotlines(bmp: array.array, vertlist: list, color: int):</code></p>
<p>Draws connected lines defined by a list of vertices</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    vertlist: [(x:uint,y:uint),...]
              list of vertices
    color   : color of the lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotpoly"><code>plotpoly</code></a></h3>
<p><code>py
def plotpoly(bmp: array.array, vertlist: list, color: int):</code></p>
<p>Draws a polygon defined by a list of vertices</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    vertlist: [(x:uint,y:uint),...]
              list of vertices
    color   : color of the lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotpolyfill"><code>plotpolyfill</code></a></h3>
<p><code>py
def plotpolyfill(bmp: array.array, vertlist: list[list[numbers.Number, numbers.Number]], color: int):</code></p>
<p>Draws a filled polygon with a given color</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    vertlist: [(x, y), ...]
              list of vertices
    color   : color of the
              filled polygon

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotpolyfillist"><code>plotpolyfillist</code></a></h3>
<p><code>py
def plotpolyfillist(bmp: array.array, sides: list[list[list[list]], list[list[float, float, float]]], RGBfactors: list[float, float]):</code></p>
<p>3D polygon rendering function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    sides     : list of polygons
                and normals
    RGBfactors: [r, g, b]
                r, g, b are
                float values
                from 0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotpolylist"><code>plotpolylist</code></a></h3>
<p><code>py
def plotpolylist(bmp: array.array, polylist: list, color: int):</code></p>
<p>Draws a list of polygons of a given color</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    polytlist: [[(x:uint,y:uint),
                ...],...]
               list of polygons
    color    : color of the lines

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreverseditalic8bitpattern"><code>plotreverseditalic8bitpattern</code></a></h3>
<p><code>py
def plotreverseditalic8bitpattern(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit reversed italic pattern</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreverseditalic8bitpatternasdots"><code>plotreverseditalic8bitpatternasdots</code></a></h3>
<p><code>py
def plotreverseditalic8bitpatternasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit reversed italic pattern as dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreverseditalicstring"><code>plotreverseditalicstring</code></a></h3>
<p><code>py
def plotreverseditalicstring(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a reversed string as Italic</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreverseditalicstringasdots"><code>plotreverseditalicstringasdots</code></a></h3>
<p><code>py
def plotreverseditalicstringasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a Reversed String as Italic dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreversestring"><code>plotreversestring</code></a></h3>
<p><code>py
def plotreversestring(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string reversed</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotreversestringasdots"><code>plotreversestringasdots</code></a></h3>
<p><code>py
def plotreversestringasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string reversed with dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotRGBxybit"><code>plotRGBxybit</code></a></h3>
<p><code>py
def plotRGBxybit(bmp: array.array, x: int, y: int, rgb: list):</code></p>
<p>Sets pixel at (x, y) in a bitmap to color [R, G, B]</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    x,y: unsigned int locations
         in x and y
    rgb: color defined by
         [R: byte, G: byte, B: byte]

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotRGBxybitvec"><code>plotRGBxybitvec</code></a></h3>
<p><code>py
def plotRGBxybitvec(bmp: array.array, v: list, rgb: list):</code></p>
<p>Sets [R, G, B] of pixel at (x, y)</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    v  : (x: float, y: float)
    rgb: [R: byte,
          G: byte,
          B: byte]

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotrotated8bitpattern"><code>plotrotated8bitpattern</code></a></h3>
<p><code>py
def plotrotated8bitpattern(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern with the bits rotated</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : where to draw
                the pattern
    bitpattern: list of bytes
                that make a pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the
                pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotrotated8bitpatternwithdots"><code>plotrotated8bitpatternwithdots</code></a></h3>
<p><code>py
def plotrotated8bitpatternwithdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit pattern with the bits rotated</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : where to draw
                the pattern
    bitpattern: list of bytes
                that make a pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the
                pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotrotated8bitpatternwithfn"><code>plotrotated8bitpatternwithfn</code></a></h3>
<p><code>py
def plotrotated8bitpatternwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Draws a 8-bit pattern with
the bits rotated with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : where to draw
                the pattern
    bitpattern: list of bytes
                that make a pattern
    scale     : control how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotrotateditalic8bitpatternwithfn"><code>plotrotateditalic8bitpatternwithfn</code></a></h3>
<p><code>py
def plotrotateditalic8bitpatternwithfn(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int, fn: Callable):</code></p>
<p>Bit rotated Italic 8-bit pattern
with a function</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the
                pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstring"><code>plotstring</code></a></h3>
<p><code>py
def plotstring(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
                      (can be an int
                           or a
                      list of ints)
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringasdots"><code>plotstringasdots</code></a></h3>
<p><code>py
def plotstringasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string as Dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringfunc"><code>plotstringfunc</code></a></h3>
<p><code>py
def plotstringfunc(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list, orderfunc: Callable, fontrenderfunc: Callable):</code></p>
<p>Draws a string</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
        `             each bit
    spacebetweenchar: space between
                      the characters
    color           : color of the font
    fontbuf         : the font
                      (see fonts.py)
    orderfunc       : function that
                      enumerates
                      each char
                      in the
                      input string
    fontrenderfunc  : function that
                      renders the font

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringsideway"><code>plotstringsideway</code></a></h3>
<p><code>py
def plotstringsideway(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string sideways</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringsidewayasdots"><code>plotstringsidewayasdots</code></a></h3>
<p><code>py
def plotstringsidewayasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string sideways as dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringsidewayfn"><code>plotstringsidewayfn</code></a></h3>
<p><code>py
def plotstringsidewayfn(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list, fn: Callable):</code></p>
<p>Draws a string sideways with a function</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringupsidedown"><code>plotstringupsidedown</code></a></h3>
<p><code>py
def plotstringupsidedown(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string upsidedown</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringupsidedownasdots"><code>plotstringupsidedownasdots</code></a></h3>
<p><code>py
def plotstringupsidedownasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string upsidedown as dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringvertical"><code>plotstringvertical</code></a></h3>
<p><code>py
def plotstringvertical(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string vertically</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringverticalasdots"><code>plotstringverticalasdots</code></a></h3>
<p><code>py
def plotstringverticalasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draws a string vertically with dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotstringverticalwithfn"><code>plotstringverticalwithfn</code></a></h3>
<p><code>py
def plotstringverticalwithfn(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list, fn: Callable):</code></p>
<p>Draws a string vertically using a function</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                     (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotupsidedownitalic8bitpattern"><code>plotupsidedownitalic8bitpattern</code></a></h3>
<p><code>py
def plotupsidedownitalic8bitpattern(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit italic pattern upsidedown</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotupsidedownitalic8bitpatternasdots"><code>plotupsidedownitalic8bitpatternasdots</code></a></h3>
<p><code>py
def plotupsidedownitalic8bitpatternasdots(bmp: array.array, x: int, y: int, bitpattern: list, scale: int, pixspace: int, color: int):</code></p>
<p>Draws a 8-bit italic pattern upsidedown as dots</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : sets where to draw
                the pattern
    bitpattern: list of bytes
                that makes the pattern
    scale     : controls how big
                the pattern is
    pixspace  : space between
                each bit in pixels
    color     : color of the pattern

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotupsidedownitalicstring"><code>plotupsidedownitalicstring</code></a></h3>
<p><code>py
def plotupsidedownitalicstring(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draw an italic string upsidedown</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotupsidedownitalicstringasdots"><code>plotupsidedownitalicstringasdots</code></a></h3>
<p><code>py
def plotupsidedownitalicstringasdots(bmp: array.array, x: int, y: int, str2plot: str, scale: int, pixspace: int, spacebetweenchar: int, color: int, fontbuf: list):</code></p>
<p>Draw an italic string upsidedown as dots</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    x, y            : sets where to
                      draw the
                      string
    str2plot        : string to draw
    scale           : control how big
                      the font is
    pixspace        : space between
                      each bit
    spacebetweenchar: space between
                      the characters
    color           : color of
                      the font
    fontbuf         : the font
                      (see fonts.py)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotvecxypoint"><code>plotvecxypoint</code></a></h3>
<p><code>py
def plotvecxypoint(bmp: array.array, v: list, c: int):</code></p>
<p>Sets the color of a pixel
    at (x, y)</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    v  : (x:float, y:float)
                or
         (x:int, y:int)
    c  : unsigned int
         color value

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotxybit"><code>plotxybit</code></a></h3>
<p><code>py
def plotxybit(bmp: array.array, x: int, y: int, c: int):</code></p>
<p>Sets pixel at (x, y) in a bitmap to color c</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    x, y: unsigned int
          locations in x and y
    c   : unsigned int color

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.plotxypointlist"><code>plotxypointlist</code></a></h3>
<p><code>py
def plotxypointlist(bmp: array.array, vlist: list, penradius: int, color: int):</code></p>
<p>Draws a circle or a point
depending on the penradius
with a given color for
all points in a point list</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    vlist    : [(x: uint, y: uint) ,...]
               list of points
    penradius: radius of the pen
               (in pixels)
    color    : color of the pen

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.polar2rectcoord2D"><code>polar2rectcoord2D</code></a></h3>
<p><code>py
def polar2rectcoord2D(vpolarcoord: list[float, float]) -&gt; list[float, float]:</code></p>
<p>Converts from polar coordinates with
origin at (0, 0) to 2D rectangular coordinates</p>
<pre><code>Args:
    vcylindcoord:(r: float,
              theta: float)

Returns:
    [x: float,
     y: float]
</code></pre>
<h3><a href="#Python_BMP.solids3D.polyboundary"><code>polyboundary</code></a></h3>
<p><code>py
def polyboundary(vertlist: list[list[int, int]]) -&gt; list[list[int, int]]:</code></p>
<p>Generates a polygon boundary
    from a list of 2D vertices</p>
<pre><code>Args:
    polybnd : list of 2D vertices
              list[list[x: int,
                        y: int]]

Returns:
    list[list[x: int, y: int]]
    A list of vertices that traces
    the boundaries of the polygon
</code></pre>
<h3><a href="#Python_BMP.colors.probplotRGBto1bit"><code>probplotRGBto1bit</code></a></h3>
<p><code>py
def probplotRGBto1bit(rgb: list[int, int, int], brightness: int) -&gt; int:</code></p>
<p>Use a non deterministic plot
    to convert 24-bit colors to
    1-bit</p>
<pre><code>Args:
    rgb: color byte values
         [r: byte,
          g: byte,
          b: byte]

Returns:
    0 or 1
</code></pre>
<h3><a href="#Python_BMP.mathlib.range2baseanddelta"><code>range2baseanddelta</code></a></h3>
<p><code>py
def range2baseanddelta(lst_range: list[int, int]):</code></p>
<p>Gets the base and range values in a list of numbers</p>
<pre><code>Args:
    lst_range: list[min: int,
                    max: int]

Returns:
    minimum value and delta of min and max value
    in lst_range
</code></pre>
<h3><a href="#Python_BMP.inttools.readint"><code>readint</code></a></h3>
<p><code>py
def readint(offset: int, cnt: int, arr: int) -&gt; int:</code></p>
<p>Reads an integer value in an
    unsigned byte array</p>
<pre><code>Args:
    offset: uint starting offset in
            buffer or array
            to read from
    cnt   : uint length of int data
            to read
    arr   : unsigned byte array
            to read int data from

Returns:
    unsigned int value
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.rectangle2file"><code>rectangle2file</code></a></h3>
<p><code>py
def rectangle2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Draws a Rectangle</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular region
    color          : color of rectangle

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.rectangle"><code>rectangle</code></a></h3>
<p><code>py
def rectangle(bmp: array.array, x1: int, y1: int, x2: int, y2: int, color: int):</code></p>
<p>Draws a Rectangle</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: the rectangular
                    region
    color         : color of the
                    rectangle

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.rectboundarycoords"><code>rectboundarycoords</code></a></h3>
<p><code>py
def rectboundarycoords(vlist: list) -&gt; list:</code></p>
<p>Returns the rectangular bounds of a list of 2D vertices</p>
<pre><code>Args:
    vlist: list[(x: int, y :int)]

Yields:
    ((min(x), min(y)),
     (max(x), max(y)))
</code></pre>
<h3><a href="#Python_BMP.primitives2D.recvert"><code>recvert</code></a></h3>
<p><code>py
def recvert(x1: int, y1: int, x2: int, y2: int) -&gt; list[list[int, int], list[int, int], list[int, int], list[int, int]]:</code></p>
<p>Creates a list of vertices for a rectangle</p>
<pre><code>Args:
    x1, y1, x1, y2: int values

Returns:
    list of vertices
    [(x1, y1), (x2, y1),
     (x2, y2), (x1, y2)]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.reduce24bitimagebits"><code>reduce24bitimagebits</code></a></h3>
<p><code>py
def reduce24bitimagebits(Existing24BMPfile: str, NewBMPfile: str, newbits: int, similaritythreshold: float, usemonopal: bool, RGBfactors: list[float, float, float] = None):</code></p>
<p>Reduce bits used to encode color in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile    : Whole path
                         to existing file
    NewBMPfile         : New file to
                         save changes in
    newbits            : can be 1, 4
                         or 8 bits
    similaritythreshold: how close can
                         a color be to
                         another color
    usemonopal         : True -&gt; image
                         will be mono
    RGBfactors         : (r: float,
                          b: float,
                          g: float)
                         values range
                         from 0 to 1
                         used only if
                         usemonopal
                         is True
Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.primitives2D.regpolygonvert"><code>regpolygonvert</code></a></h3>
<p><code>py
def regpolygonvert(cx: int, cy: int, r: int, sides: int, angle: float) -&gt; list[list[int, int]]:</code></p>
<p>Creates a list of int vertices for a regular polygon</p>
<pre><code>Args:
    cx, cy: int center of a circle
    r     : int radius of a circle
            that circumscribes the
            regular polygon
    sides : int sides of the
            regular polygon
    angle:  angle of rotation
            of the polygon in
            degrees

Returns:
    list of int vertices
    [(x, y), ...]
</code></pre>
<h3><a href="#Python_BMP.bufresize.resizebufNtimesbigger"><code>resizebufNtimesbigger</code></a></h3>
<p><code>py
def resizebufNtimesbigger(buf: array.array, n: int, bits: int) -&gt; array.array:</code></p>
<p>Resize a buffer n times bigger
    given a particular bit depth n</p>
<pre><code>Args:
    buf : array to resize
    n   : resize factor
    bits: bit depth of
          color info
          (1, 4, 8, 24) bits

Returns:
    list
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.resizeNtimesbigger2file"><code>resizeNtimesbigger2file</code></a></h3>
<p><code>py
def resizeNtimesbigger2file(ExistingBMPfile: str, NewBMPfile: str, n: int):</code></p>
<p>Resize a bitmap file n times bigger</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.resizeNtimesbigger"><code>resizeNtimesbigger</code></a></h3>
<p><code>py
def resizeNtimesbigger(bmp: array.array, n: int):</code></p>
<p>Resize an in-memory bmp
    n times bigger</p>
<pre><code>Args:
    buf : array to resize
    n   : resize factor
    bits: bit depth of
          the color info
          (1, 4, 8, 24)

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.resizeNtimessmaller2file"><code>resizeNtimessmaller2file</code></a></h3>
<p><code>py
def resizeNtimessmaller2file(ExistingBMPfile: str, NewBMPfile: str, n: int):</code></p>
<p>Resize a bitmap file n times smaller</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.resizeNtimessmaller"><code>resizeNtimessmaller</code></a></h3>
<p><code>py
def resizeNtimessmaller(bmp: array.array, n: int) -&gt; array.array:</code></p>
<p>Resize a whole image int n times smaller</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    n  : int resize factor

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.bufresize.resizesmaller24bitbuf"><code>resizesmaller24bitbuf</code></a></h3>
<p><code>py
def resizesmaller24bitbuf(buf: array.array) -&gt; array.array:</code></p>
<p>Resize a 24-bit buffer
    n times smaller</p>
<pre><code>Args:
    buf: unsigned byte array
    n  : buffer multiplier

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.colors.RGB2BGRarr"><code>RGB2BGRarr</code></a></h3>
<p><code>py
def RGB2BGRarr(r: int, g: int, b: int) -&gt; array.array:</code></p>
<p>Returns a bgr array from
    individual r, g and b color
    component inputs</p>
<pre><code>Args:
    r, g, b: byte color values

Returns:
    unsigned byte BGR array
</code></pre>
<h3><a href="#Python_BMP.colors.RGB2BGRbuf"><code>RGB2BGRbuf</code></a></h3>
<p><code>py
def RGB2BGRbuf(buf: array.array):</code></p>
<p>Convert an RGB buffer
         to a BGR buffer</p>
<pre><code>Args:
    buf: unsigned byte array
         holding RGB data

Returns:
    byref unsigned byte array
    holding BGR data
</code></pre>
<h3><a href="#Python_BMP.colors.RGB2HSL"><code>RGB2HSL</code></a></h3>
<p><code>py
def RGB2HSL(r: int, g: int, b: int) -&gt; list[int, int, int]:</code></p>
<p>Converts an RGB value to HSL</p>
<pre><code>Args:
    r: unsigned byte red value
    g: unsigned byte green value
    b: unsigned byte blue value

Returns:
    [hue: int,  -&gt;  in degrees
     sat: int,  -&gt;  percentage
     lum: int]  -&gt;  percentage
</code></pre>
<h3><a href="#Python_BMP.colors.RGB2int"><code>RGB2int</code></a></h3>
<p><code>py
def RGB2int(r: int, g: int, b: int) -&gt; int:</code></p>
<p>Pack byte r, g and b color value
    components to an int
    representation for a
    specific color</p>
<pre><code>Args:
    r, g, b: color byte values

Returns:
    int color val
</code></pre>
<h3><a href="#Python_BMP.colors.RGBfactors2RGB"><code>RGBfactors2RGB</code></a></h3>
<p><code>py
def RGBfactors2RGB(RGBfactors: list[float, float, float], bytelum: int) -&gt; list[int, int, int]:</code></p>
<p>Mix a byte luminosity value to
    an rgb triplet that express
    a color value in [r, g, b]
    ratios from 0.0 to 1.0 to
    obtain byte r, g, b values
    stored in a list [r, g, b]</p>
<pre><code>Args:
    lum       : a byte value for
                luminosity
    RGBfactors: list[r: float,
                     g: float,
                     b: float]
                float values from
                0.0 to 1.0

Returns:
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.colors.RGBfactorstoBaseandRange"><code>RGBfactorstoBaseandRange</code></a></h3>
<p><code>py
def RGBfactorstoBaseandRange(lumrange: list[int, int], rgbfactors: list[float, float, float]):</code></p>
<p>Get base color luminosity and
    luminosity range from color
    expressed as r, g, b  float
    values and min and max byte
    luminosity values</p>
<pre><code>Args:
    lumrange: [minval: byte
               maxval: byte]

    rgbfactors: color  as
                [r: float,
                 g: float,
                 b: float]

Returns:
    base luminosity as
    [r: byte, g: byte, b: byte]

    luminosity range as
    [r: byte, g: byte, b: byte]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.RGBpalbrightnessadjust"><code>RGBpalbrightnessadjust</code></a></h3>
<p><code>py
def RGBpalbrightnessadjust(bmp: array.array, percentadj: float) -&gt; list:</code></p>
<p>Copies the RGB palette info from
a source unsigned byte array to
a destination unsigned byte array</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    percentadj: signed float
                brightness adj in %

Returns:
    list of modified RGB values
</code></pre>
<h3><a href="#Python_BMP.mathlib.rotatebits"><code>rotatebits</code></a></h3>
<p><code>py
def rotatebits(bits: int) -&gt; int:</code></p>
<p>Rotates the bits in a byte</p>
<pre><code>Args:
    bits: the int 8 bits to rotate

Returns:
    int value of rotated 8 bits
</code></pre>
<h3><a href="#Python_BMP.bufferflip.rotatebitsinbuf"><code>rotatebitsinbuf</code></a></h3>
<p><code>py
def rotatebitsinbuf(buf: array.array) -&gt; array.array:</code></p>
<p>Does a bit rotate to the bytes
    in an unsigned byte array</p>
<pre><code>Args:
    buf: unsigned byte array

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.solids3D.rotvec3D"><code>rotvec3D</code></a></h3>
<p><code>py
def rotvec3D(roll: float, pitch: float, yaw: float) -&gt; tuple:</code></p>
<p>Returns a 3D rotation vector</p>
<pre><code>Args:
    All input arguements are in
    degrees (roll, pitch, yaw)

Returns:
    tuple ((float, float),
           (float, float),
           (float, float))
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.roundpen"><code>roundpen</code></a></h3>
<p><code>py
def roundpen(bmp: array.array, point: list, penradius: int, color: int):</code></p>
<p>Draws a circle or a point
depending on the penradius
with a given color</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    point    : (x:uint,y:uint)
               centerpoint
    penradius: radius of the
               pen in pixels
    color    : color of the pen

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.roundvect"><code>roundvect</code></a></h3>
<p><code>py
def roundvect(v: list[numbers.Number]) -&gt; list[int]:</code></p>
<p>Rounds off the components of a vector
   (list of floats -&gt; list of ints)</p>
<pre><code>Args:
    v: list of floats

Returns:
    list of ints
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.saveBMP"><code>saveBMP</code></a></h3>
<p><code>py
def saveBMP(filename: str, bmp: array.array):</code></p>
<p>Saves bitmap to file</p>
<pre><code>Args:
    filename: full path to
              the file to be saved
    bmp     : unsigned byte array
              with the layout of
              a bitmap file
Returns:
    A Bitmap File
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.setBMP2monochrome"><code>setBMP2monochrome</code></a></h3>
<p><code>py
def setBMP2monochrome(bmp: array.array, RGBfactors: list[float, float, float]) -&gt; list:</code></p>
<p>Sets a bitmap to use a monochrome palette</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    RGBfactors: (r, g, b)
                all values range
                from 0.0 to 1.0

Returns:
    list of modified RGB values
    byref modified byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.setBMPimgbytes"><code>setBMPimgbytes</code></a></h3>
<p><code>py
def setBMPimgbytes(bmp: array.array, buf: array.array):</code></p>
<p>Sets the raw image buffer of a bitmap</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format
    buf: array of unsigned bytes

Returns:
    byref modified  unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.setbmppal"><code>setbmppal</code></a></h3>
<p><code>py
def setbmppal(bmp: array.array, pallist: list):</code></p>
<p>Sets the RGB palette of a bitmap</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    pallist: [(r: byte,
               g: byte,
               b: byte), ...]

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.setmax"><code>setmax</code></a></h3>
<p><code>py
def setmax(val: numbers.Number, maxval: numbers.Number) -&gt; numbers.Number:</code></p>
<p>Set the value of val to maxval if val &gt; maxval</p>
<pre><code>Args:
    val   : numeric variable
    maxval: upper limit of variable

Returns:
    Number
</code></pre>
<h3><a href="#Python_BMP.mathlib.setmin"><code>setmin</code></a></h3>
<p><code>py
def setmin(val: numbers.Number, minval: numbers.Number) -&gt; numbers.Number:</code></p>
<p>Set the value of val to minval if val &lt; minval</p>
<pre><code>Args:
    val   : numeric variable
    minval: lower limit of variable

Returns:
    Number
</code></pre>
<h3><a href="#Python_BMP.mathlib.setminmax"><code>setminmax</code></a></h3>
<p><code>py
def setminmax(val: numbers.Number, minval: numbers.Number, maxval: numbers.Number) -&gt; numbers.Number:</code></p>
<p>Set the value of val to minval if val &lt; minval
or the value of val to maxval if val &gt; maxval</p>
<pre><code>Args:
    val   : numeric variable
    minval: lower limit of variable
    maxval: upper limit of variable

Returns:
    Number
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.setnewpalfromsourcebmp"><code>setnewpalfromsourcebmp</code></a></h3>
<p><code>py
def setnewpalfromsourcebmp(sourcebmp: array.array, newbmp: array.array, similaritythreshold: float) -&gt; list:</code></p>
<p>Copies the RGB palette info from
a source unsigned byte array
to a destination unsigned byte array
(source and destination
can have different bit depths)</p>
<pre><code>Args:
    sourceBMP, newBMP  : unsigned
                         byte arrays
                         with
                         bmp format
    similaritythreshold: how close
                         can a color
                         in a palette
                         entry be to
                         another color

Returns:
    byRef modified newBMP
    (unsigned byte array) and a
    list of new palette entries
    based on source bitmap
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.setRGBpal"><code>setRGBpal</code></a></h3>
<p><code>py
def setRGBpal(bmp: array.array, c: int, r: int, g: int, b: int):</code></p>
<p>Sets the r,g,b values of color c in a bitmap</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    r, g, b: unsigned byte values
             for red, green and
             blue
    c      : unsigned int color

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.showsimilarparts"><code>showsimilarparts</code></a></h3>
<p><code>py
def showsimilarparts(inputfile1: str, inputfile2: str, diff_file: str):</code></p>
<p>Compares 2 files and saves the similar parts to a BMP</p>
<pre><code>Args:
    inputfile1: Whole paths
    inputfile2  to existing files

    diff_file : New file to
                store similar parts

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.primitives2D.sortrecpoints"><code>sortrecpoints</code></a></h3>
<p><code>py
def sortrecpoints(x1: int, y1: int, x2: int, y2: int):</code></p>
<p>Sorts the x and y values that sets a rectangular area</p>
<pre><code>Args:
    x1, x2: int x coordinates
    y1, y2: int y coordinates

Returns:
    sorted coordinates
    x1, y1, x2, y2
    such that
    x1 &lt; x2 and y1 &lt; y2
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.sphere2file"><code>sphere2file</code></a></h3>
<p><code>py
def sphere2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>Renders a sphere</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x, y, r        : center (x, y)
                     and radius r
    rgbfactors     : (r, g, b)
                     values
                     range from
                     0.0 to 1.0

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.sphere"><code>sphere</code></a></h3>
<p><code>py
def sphere(bmp: array.array, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>Draws a Rendered Sphere</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : center of sphere
                in the image
    r         : radius of sphere
                in pixels
    rgbfactors: (r,g,b) r, g and b
                values range from
                0.0 to 1.0

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.solids3D.spherevertandsurface"><code>spherevertandsurface</code></a></h3>
<p><code>py
def spherevertandsurface(vcen: list[float, float, float], r: float, deganglestep: float) -&gt; tuple:</code></p>
<p>Returns a list of sparse
    vertices and tiled surfaces
    for a sphere</p>
<pre><code>Args:
    vcen       : [x: float, center
                  y: float, of the
                  z: float] sphere
    r           : spherical radius
    deganglestep: angle step between
    vertices that controls how sparse
    the list will be

Returns:
    list of vertices and surfaces
    for plot3Dsolid()
    see Hello_DiscoBall.py
    and Hello_Globe.py
</code></pre>
<h3><a href="#Python_BMP.primitives2D.spiralcontrolpointsvert"><code>spiralcontrolpointsvert</code></a></h3>
<p><code>py
def spiralcontrolpointsvert(x: int, y: int, step: int, growthfactor: float, turns: int):</code></p>
<p>Returns a list of 2D vertices of a Square Spiral</p>
<pre><code>Args:
    x, y: int centerpoint
              coordinates
    step: int step increment
    growthfactor: float multiplier
                  to step increment
                  to make exponential
                  spirals
    turns: number of turns of the
           spiral

Returns:
    list of vertices of the spiral
    list[[x: int, y: int]]
</code></pre>
<h3><a href="#Python_BMP.primitives2D.spirographvert"><code>spirographvert</code></a></h3>
<p><code>py
def spirographvert(x: int, y: int, r: int, l: float, k: float, delta: float, lim: float):</code></p>
<p>Returns a list(int, int) of
2D vertices along a path defined
by a spirograph with scaling factor r
and dimensionless parametersl and k
with an origin set at (x, y)</p>
<pre><code>Args:
    x, y : center of the spirograph
    r    : spirograph scaling factor
    l, k : spirograph shape parameters
    delta: angle increment in radians
    lim  : angle limit in radians

Returns:
    The vertices of an
    spirograph in a list
    [[x: int, y: int], ...]
</code></pre>
<h3><a href="#Python_BMP.mathlib.subvect"><code>subvect</code></a></h3>
<p><code>py
def subvect(u: list[numbers.Number], v: list[numbers.Number]) -&gt; list[numbers.Number]:</code></p>
<p>Subtracts vectors u and v by subtracting their components</p>
<pre><code>Args:
    u, v: list of ints or floats

Returns:
    list of ints or floats
</code></pre>
<h3><a href="#Python_BMP.solids3D.surfplot3Dvertandsurface"><code>surfplot3Dvertandsurface</code></a></h3>
<p><code>py
def surfplot3Dvertandsurface(x1: int, y1: int, x2: int, y2: int, step: int, fnxy: Callable) -&gt; tuple:</code></p>
<p>Does a 3D surface plot of a
    function z = fnxy(x, y)</p>
<pre><code>Args:
    x1, y1, x2, y2: set drawing area
    fnxy          : fnxy(x, y)
                    Callable
                    (lambda or fn)

Returns:
    list of vertices and surfaces
    for plot3Dsolid()
    see Hello_3D_surfaceplot.py
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.swapcolors"><code>swapcolors</code></a></h3>
<p><code>py
def swapcolors(bmp: array.array, p1: list, p2: list):</code></p>
<p>Swaps the colors of two points in a BMP</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    p1, p2: endpoints of the
            line(x: uint, y: uint)

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.conditionaltools.swapif"><code>swapif</code></a></h3>
<p><code>py
def swapif(val1: &lt;built-in function any&gt;, val2: &lt;built-in function any&gt;, boolcond: bool):</code></p>
<p>Swaps val1 and val2 if
    boolcond is true</p>
<pre><code>Args:
    boolcond  : an expression that
                evaluates as either
                True or False
    val1, val2: values to swap if
                boolcond is True

Returns:
    values depending on boolcond
</code></pre>
<h3><a href="#Python_BMP.mathlib.swapxy"><code>swapxy</code></a></h3>
<p><code>py
def swapxy(v: list) -&gt; list:</code></p>
<p>Swaps the first two values in a list</p>
<pre><code>Args:
    list[x, y]

Returns:
    list[y, x]
</code></pre>
<h3><a href="#Python_BMP.solids3D.tetrahedravert"><code>tetrahedravert</code></a></h3>
<p><code>py
def tetrahedravert(x: float) -&gt; list[list[float, float, float]]:</code></p>
<p>Returns a list of vertices
    for a tetrahedron</p>
<pre><code>Args:
    x: length of a side

Returns:
    list (x: float,
          y: float,
          z: float)
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickcircle"><code>thickcircle</code></a></h3>
<p><code>py
def thickcircle(bmp: array.array, x: int, y: int, r: int, penradius: int, color: int):</code></p>
<p>Draws a Thick Circle</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    x, y, r  : center (x, y)
               and radius r
    penradius: radius of round pen
    color    : color of the circle

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickellipserot"><code>thickellipserot</code></a></h3>
<p><code>py
def thickellipserot(bmp: array.array, x: int, y: int, b: int, a: int, degrot: float, penradius: int, color: int):</code></p>
<p>Draws a Thick Ellipse</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : center of ellipse
    b, a      : major and minor axis
    degrot    : rotation of
                the ellipse in degrees
    penradius : thickness of the pen
    color     : color of the ellipse

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickencirclearea2file"><code>thickencirclearea2file</code></a></h3>
<p><code>py
def thickencirclearea2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>"Encircle area with a gradient and save to a file</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format

    x, y      : center of circle
    r         : radius of circle
    rgbfactors: (r, g, b) values
                are from 0.0 to 1.0

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickencirclearea"><code>thickencirclearea</code></a></h3>
<p><code>py
def thickencirclearea(bmp: array.array, x: int, y: int, r: int, rgbfactors: list[float, float, float]):</code></p>
<p>Encircle area with a gradient</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    x, y      : center of circle
    r         : radius of circle
    rgbfactors: (r,g,b) r, g and b
                values are 0 to 1
                unsigned floats

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickplotpoly"><code>thickplotpoly</code></a></h3>
<p><code>py
def thickplotpoly(bmp: array.array, vertlist: list[list[numbers.Number, numbers.Number]], penradius: int, color: int):</code></p>
<p>Draws a polygon of a given color and thickness</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    vertlist : [(x, y)...]
               list of vertices
    penradius: radius of pen
    color    : color of the polygon

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thickroundline"><code>thickroundline</code></a></h3>
<p><code>py
def thickroundline(bmp: array.array, p1: list, p2: list, penradius: int, color: int):</code></p>
<p>Draw a Thick Rounded Line</p>
<pre><code>Args:
    bmp       : unsigned byte array
                with bmp format
    p1, p2    : (x, y) endpoints
                of the line
    penradius : radius of pen
                in pixels
    color     : color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thresholdadjcircregion2file"><code>thresholdadjcircregion2file</code></a></h3>
<p><code>py
def thresholdadjcircregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Threshold adjustment to a circular region in a 24-bit BMP</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
    lumrange       : (byte:byte)
                     threshold range

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thresholdadjcircregion"><code>thresholdadjcircregion</code></a></h3>
<p><code>py
def thresholdadjcircregion(bmp: array.array, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Threshold adjustment to a circular area</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    x, y, r  : centerpoint (x, y)
               and radius r
    lumrange : (byte: byte)
               threshold adjustment
               luminosity range

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thresholdadjto24bitimage"><code>thresholdadjto24bitimage</code></a></h3>
<p><code>py
def thresholdadjto24bitimage(bmp: array.array, lumrange: list[int, int]):</code></p>
<p>Threshold adjustment to a whole BMP</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    lumrange: (byte: byte)
              threshold adjustment
              luminosity range

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thresholdadjto24bitregion"><code>thresholdadjto24bitregion</code></a></h3>
<p><code>py
def thresholdadjto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int]):</code></p>
<p>Threshold adjustment to a rectangular area</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: ints that defines
                    the rectangular
                    region
    lumrange      : (byte:byte)
                    threshold
                    adjustment
                    luminosity range

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.thresholdadjust2file"><code>thresholdadjust2file</code></a></h3>
<p><code>py
def thresholdadjust2file(ExistingBMPfile: str, NewBMPfile: str, lumrange: list[int, int]):</code></p>
<p>Apply a threshold adjustment</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    lumrange       : (byte:byte)
                     threshold
                     to apply

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.colors.thresholdadjust"><code>thresholdadjust</code></a></h3>
<p><code>py
def thresholdadjust(rgb: list[int, int, int], lumrange: list[int, int]) -&gt; list[int, int, int]:</code></p>
<p>Apply a threshold adjustment
    to a rgb</p>
<pre><code>Args:
    rgb: color as [r: byte,
                   g: byte,
                   b: byte]
    lumrange: [min: byte,
               max: byte]
              brightness
              threshold
              adjustment
              limits

Returns:
    a brightness threshold adjusted
    color as [r: byte,
              g: byte,
              b: byte]
</code></pre>
<h3><a href="#Python_BMP.mathlib.trans"><code>trans</code></a></h3>
<p><code>py
def trans(vlist: list[list[numbers.Number]], u: list[numbers.Number]) -&gt; list[list[numbers.Number]]:</code></p>
<p>Translates list of vectors by adding vector u
to all vectors in the list of vectors</p>
<pre><code>Args:
    vlist: list of vectors
    u    : translation vector

Returns:
    list of vectors
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.upgradeto24bitimage2file"><code>upgradeto24bitimage2file</code></a></h3>
<p><code>py
def upgradeto24bitimage2file(ExistingBMPfile: str, NewBMPfile: str):</code></p>
<p>Upgrades a bitmap file to 24-bits</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.upgradeto24bitimage"><code>upgradeto24bitimage</code></a></h3>
<p><code>py
def upgradeto24bitimage(bmp: array.array):</code></p>
<p>Upgrade an image to 24-bits</p>
<pre><code>Args:
    bmp: unsigned byte array
         with bmp format

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.userdef2Dcooordsys2screenxy"><code>userdef2Dcooordsys2screenxy</code></a></h3>
<p><code>py
def userdef2Dcooordsys2screenxy(x: int, y: int, lstcooordinfo: list):</code></p>
<p>2D coordinate trans from user to screen</p>
<pre><code>Args:
    x, y         : user coordinates
    lstcooordinfo: info on how to
                   transform the
                   2D coordinate
                   system
                   [origin,
                    steps,
                    xylimits,
                    xyvalstarts,
                    xysteps]
                    all
                    (x: int,
                     y: int) pairs

Returns:
    [x: int, y: int] screen coordinates
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.vertBMPbitBLTget"><code>vertBMPbitBLTget</code></a></h3>
<p><code>py
def vertBMPbitBLTget(bmp: array.array, x: int, y1: int, y2: int) -&gt; array.array:</code></p>
<p>Gets vertical slice to a new array</p>
<pre><code>Args:
    bmp   : unsigned byte array
            with bmp format
    x     : unsigned int x
    y1, y2  and y coordinates

Returns:
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.vertbrightnessgrad2circregion2file"><code>vertbrightnessgrad2circregion2file</code></a></h3>
<p><code>py
def vertbrightnessgrad2circregion2file(ExistingBMPfile: str, NewBMPfile: str, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Vertical brightness gradient to a circular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes to
    x, y, r        : center (x, y)
                     and radius r
                     of a circular
                     region
    lumrange       : brightness
                     gradient
                     (byte: byte)
                     adjust

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.vertbrightnessgrad2circregion"><code>vertbrightnessgrad2circregion</code></a></h3>
<p><code>py
def vertbrightnessgrad2circregion(bmp: array.array, x: int, y: int, r: int, lumrange: list[int, int]):</code></p>
<p>Vertical brightness gradient adjustment to a circular area</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    x, y, r : center (x,y)
              and radius r
    lumrange: [byte,byte]
              that define
              the range of
              luminosity

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verticalbrightnessgrad2file"><code>verticalbrightnessgrad2file</code></a></h3>
<p><code>py
def verticalbrightnessgrad2file(ExistingBMPfile: str, NewBMPfile: str, lumrange: list[int, int]):</code></p>
<p>Applies a Vertical brightness gradient</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    lumrange       : (byte:byte)
                     defines the
                     brightness
                     gradient

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verticalbrightnessgradregion2file"><code>verticalbrightnessgradregion2file</code></a></h3>
<p><code>py
def verticalbrightnessgradregion2file(ExistingBMPfile: str, NewBMPfile: str, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int]):</code></p>
<p>Vertical brightness gradient to a rectangular area</p>
<pre><code>Args:
    ExistingBMPfile: Whole path to
                     existing file
    NewBMPfile     : New file to
                     save changes in
    x1, y1, x2, y2 : defines the
                     rectangular
                     region
    lumrange       : (byte:byte)
                     defines the
                     brightness
                     gradient

Returns:
    new bitmap file
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verticalbrightnessgradto24bitimage"><code>verticalbrightnessgradto24bitimage</code></a></h3>
<p><code>py
def verticalbrightnessgradto24bitimage(bmp: array.array, lumrange: list[int, int]):</code></p>
<p>Applies a vertical brightness gradient</p>
<pre><code>Args:
    bmp     : unsigned byte array
              with bmp format
    lumrange: (byte: byte) the
              brightness gradient

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verticalbrightnessgradto24bitregion"><code>verticalbrightnessgradto24bitregion</code></a></h3>
<p><code>py
def verticalbrightnessgradto24bitregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, lumrange: list[int, int]):</code></p>
<p>Apply a vertical brightness gradient
to a rectangular area in a 24-bit bitmap</p>
<pre><code>Args:
    bmp          :  unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: defines the
                    rectangular
                    region
    lumrange      : (byte:byte)
                    brightness
                    gradient

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.primitives2D.verticalvert"><code>verticalvert</code></a></h3>
<p><code>py
def verticalvert(x: int, y1: int, y2: int, dy: int) -&gt; list[list[int, int]]:</code></p>
<p>Creates a list of int vertices
along a vertical line with int step dy</p>
<pre><code>Args:
    x : int constant x
    y1: int start point
    y2: int end point
    dy: int y step increment

Returns:
    list of int vertices
    [(x, y), ...]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.vertline"><code>vertline</code></a></h3>
<p><code>py
def vertline(bmp: array.array, x: int, y1: int, y2: int, color: int):</code></p>
<p>Draw a Vertical Line</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    x    : constant x value
           of the line
    y1   : starts at y1
    y2   : ends at y2
    color: color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.vertlinevert"><code>vertlinevert</code></a></h3>
<p><code>py
def vertlinevert(bmp: array.array, vlist: list[list[int, int]], linelen: int, yadj: int, color: int):</code></p>
<p>Vertical line marks at vertices in vlist</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    vlist  : [(x,y),...] the
             list of vertices
    linelen: lenght of the
             vertical lines
    yadj   : sets an adjustment
             for y coordinates
    color  : color of the line

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verttrans"><code>verttrans</code></a></h3>
<p><code>py
def verttrans(bmp: array.array, trans: str):</code></p>
<p>Do vertical image transforms</p>
<pre><code>Args:
    bmp : unsigned byte array
          with bmp format
    tran: single letter
          transform code
          'T' - mirror top-half
          'B' - mirror bottom-half
          'F' - flip

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verttransformincircregion"><code>verttransformincircregion</code></a></h3>
<p><code>py
def verttransformincircregion(bmp: array.array, x: int, y: int, r: int, trans: str):</code></p>
<p>Applies a vertical transform to
a circular region with a center
at (x, y) and radius r</p>
<pre><code>Args:
    bmp    : unsigned byte array
             with bmp format
    x, y, r: center (x, y)
             and radius r
             of region
    trans  :single letter
            transform code
            'T' mirror top
            'B' mirror bottom
            'F' flip

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.verttransregion"><code>verttransregion</code></a></h3>
<p><code>py
def verttransregion(bmp: array.array, x1: int, y1: int, x2: int, y2: int, trans: str):</code></p>
<p>Do vertical image transforms
    in a rectangular region</p>
<pre><code>Args:
    bmp            : unsigned
                     byte array
                     with bmp format
    x1, y1, x2, y2 : ints that
                     defines the
                     rectangular
                     region
    trans          : single letter
                     transform code
            'T' - mirror top half
            'B' - mirror bottom half
            'F' - flip

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.vmag"><code>vmag</code></a></h3>
<p><code>py
def vmag(v: list[float]) -&gt; float:</code></p>
<p>Compute the Magnitude or length of a vector v
of arbitrary dimension n equal to len(v)</p>
<pre><code>Args:
    v: list of ints or floats

Returns:
    float
</code></pre>
<h3><a href="#Python_BMP.inttools.writeint"><code>writeint</code></a></h3>
<p><code>py
def writeint(offset: int, cnt: int, arr: array.array, value: int):</code></p>
<p>Writes an integer value to an
    unsigned byte array</p>
<pre><code>Args:
    offset: uint starting offset in
            buffer or array
            to write to
    cnt   : uint length of int data
            to write
    arr   : unsigned byte array
            to write int data in
    value : value of uint data to
            write in buffer or
            array

Returns:
    byref unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.mathlib.xorvect"><code>xorvect</code></a></h3>
<p><code>py
def xorvect(u: list[int], v: list[int]) -&gt; list[int]:</code></p>
<p>Applies a xor operation of between the elements of
two lists of ints</p>
<pre><code>Args:
    v      : list[int]
    bitmask: int

Returns:
    list[int]
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.XYaxis"><code>XYaxis</code></a></h3>
<p><code>py
def XYaxis(bmp: array.array, origin: list[int, int], steps: list[int, int], xylimits: list[int, int], xyvalstarts: list[numbers.Number, numbers.Number], xysteps: list[numbers.Number, numbers.Number], color: int, textcolor: int, showgrid: bool, gridcolor: int):</code></p>
<p>XY axis with tick marks and numbers</p>
<pre><code>Args:
    bmp      : unsigned byte array
               with bmp format
    origin   : (x, y) on screen
                origin point
                of the axis
    steps    : (x, y) steps between
               tick marks onscreen
    xylimits : (x, y) sets where the
               graph ends onscreen
    xyvalstarts: (x, y) sets the
                  start point of
                  x and y number
                  lines
    xysteps   : (x, y) sets the
                number increment
                along the x and y
                numberlines
    color    : color of the lines
    textcolor: color of the
               numberline text
    showgrid : True -&gt; display
                       gridline
               False -&gt; no grid
    gridcolor: color of the grid

Returns:
    byref modified
    unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.xygrid"><code>xygrid</code></a></h3>
<p><code>py
def xygrid(bmp: array.array, x1: int, y1: int, x2: int, y2: int, xysteps: list[int, int], color: int):</code></p>
<p>Draws a grid</p>
<pre><code>Args:
    bmp           : unsigned
                    byte array
                    with bmp format
    x1, y1, x2, y2: sets limits
                    of the grid
    xysteps       : [x, y] sets the
                    increments
    color         : sets the color
                    of the grid

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.xygridvec"><code>xygridvec</code></a></h3>
<p><code>py
def xygridvec(bmp: array.array, u: list[int, int], v: list[int, int], steps: list[int, int], gridcolor: int):</code></p>
<p>Grid using (x, y) point pairs u and v</p>
<pre><code>Args:
    bmp  : unsigned byte array
           with bmp format
    u, v : (x, y) sets limits
            of the  grid
    steps: (x, y) -&gt; sets the
           increments for x and y
    color: sets the color
           of the grid

Returns:
    byref modified unsigned byte array
</code></pre>
<h3><a href="#Python_BMP.BITMAPlib.XYscatterplot"><code>XYscatterplot</code></a></h3>
<p><code>py
def XYscatterplot(bmp: array.array, XYdata: list, XYcoordinfo: list, showLinearRegLine: bool, reglinecolor: int):</code></p>
<p>Create a XY scatterplot</p>
<pre><code>Args:
    bmp             : unsigned
                      byte array
                      with bmp format
    XYData          : [[x,y,
                      radius
                      (max radius is 5),
                      isfilled],...]
    lstcooordinfo   : info on how to
                      transform the
                      coordinate system
                      [origin,
                       -&gt; origin point
                          on screen
                      steps,
                       -&gt; on screen steps
                      xylimits,
                       -&gt; x and y
                          clipping limit
                      xyvalstarts,
                       -&gt; number line
                          start values
                      xysteps
                       -&gt; increments for
                          the number lines
                        ]
                      * (x:int,y:int) pairs
    howLinearRegLine: True -&gt; display linear
                              regression line
    reglinecolor    : color of linear
                      regression line

Returns:
    byref modified unsigned byte array
</code></pre>